/*-------------------------------------------------------------------------------------------------------
	C++'ta // ile satır sonuna kadar yorumlama yapılabilir (C99'da da var)
-------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main()
{
	// This is a test

	return 0;
}

/*---------------------------------------------------------------------------------------------------------
	C++'ta yerel değişkenler blokların herhangi bir yerinde bildirilebilir
---------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main()
{
	printf("This is a test\n");

	int i = 10;			// C'de geçersiz C++'ta geçerli
	printf("%d\n", i);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta for döngüsünün birinci kısmında, while, if switch deyimlerinin içerisinde bildirim yapılabilir
---------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main()
{
	for (int i = 0; i < 10; ++i)
		printf("%d\n", i);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta diğer deyimlerin parantezleri içerisinde de bidiirmler yapılabilir. Bu durumda bildirilen değişkene
	ilkdeğer verilmek zorundadır. Test işlemlerine bu değişken içeirisndki değerler sokulur.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int foo()
{
	static int i = 10;

	--i;

	return i;
}

int main()
{
	for (int i = 0; i < 10; ++i)
		printf("%d\n", i);

	while (int x = foo()) 
		printf("%d\n", x);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	for döngülerinin birinci kısmında bildiirlen değişkenler for döngüsünün içerisinde kullanılabilirler
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	for (int i = 0; i < 10; ++i) {
			// i'yi kullanırsak bu for döngüsünün i'si anlaşılır
		for (int i = 0; i < 10; ++i) {
			// i'yi kullanırsak bu for döngüsünün i'si anlaşılır
		}
	}
	// Burada artıık hiçbir i'yi kullanamayız

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Ayunı bloktaki for döngülerinin birinci kısmında aynı isimli değişkenlerin bildirilmesi soruna yol açmaz
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	for (int i = 0; i < 10; ++i)
		printf("%d\n", i);

	for (int i = 0; i < 10; ++i)		// geçerli!
		printf("%d\n", i);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Referanslar aynı türden bir nesneyle ilkdeğer verilerek tanımlanırlar. Bu duurmda derleyici referansa
	ilkdeğer olarak verilen nesnenin adresini yerleştirir.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int a;
	int &r = a;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir referans kullanıldığında her zaman içerisindeki adresteki nesne kullanılmış olur.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int a = 10;
	int &r = a;

	printf("%d\n", a);		// 10
	r = 20;
	printf("%d\n", a);		// 20
	printf("%d\n", r);		// 20

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Referanslar
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int a = 10;
	int &r = a;
	int &k = r;

	printf("%d\n", r);		// 10
	printf("%d\n", k);		// 10

	return 0;	
}

/*--------------------------------------------------------------------------------------------------------
	Bir fonksiyonun parametre değişkeni bir refeans olabilir. Bu durumda biz fonksiyonu aynı türden bir
	nesneyle çağırmak zorundayız. Böylece nesnenin adresi fonksiyonun parametre değişkeni olan referansa 
	atanmış olacaktır.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void foo(int &r)		
{
	printf("%d\n", r);
}

int main()
{
	int a = 10;

	foo(a);
	
	return 0;	
}

/*--------------------------------------------------------------------------------------------------------
	Fonksiyon parametresi olarak referanslar
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void foo(int &r)		
{
	r = 20;
}

int main()
{
	int a = 10;

	foo(a);
	printf("%d\n", a);		// 20
	
	return 0;	
}

/*--------------------------------------------------------------------------------------------------------
	Referanslarla swap fonksiyonunun yazımı
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void swap(int &a, int &b)
{
	int temp = a;
	a = b;
	b = temp;
}

int main()
{
	int x = 10, y = 20;

	swap(x, y);
	printf("x = %d, y = %d\n", x, y);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Yapılar da referanslar yoluyla fonksiyonlara parametre olarak geçirilebilirler. Bir yapı referansıyla
	yapının elemanlarına erişmek için nokta operatörü kullanılmaktadır..
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

struct DATE {
	int day, month, year;
};

void disp_date(struct DATE &date)
{
	printf("%d/%d/%d\n", date.day, date.month, date.year);
}

int main()
{
	struct DATE date = { 12, 11, 2010 };

	disp_date(date);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const referanslar
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int a = 10;
	const int &r = a;		// const int *r = &a;

	printf("%d\n", r);		// geçerli
	r = 20;					// error!

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const bir referans farklı türden bir nesneyle ilkdeğer verilerek tanımlanamabilir. Bu durumda derleyici
	referans ile aynı türden geçici bir nesne yaratır. İlkdeğer olarak verilen nesnein içindeki değeri 
	bu geçici nesneye atar ve geçici nesnenin adresini referansa yerleştirir. 
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	long a = 10;
	const int &r = a;

	printf("%d\n", r);		/* 10 */
	a = 20;
	printf("%d\n", r);		/* 10 */

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const bir referans sabitle ilkdeğer verilerek de tanımlanabilir. Bu durumda sabit değer aynı türdne bir
	geçici nesnenin içerisine yerleştirilir ve geçici nesnenin adresi referansa atanır.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	const int &r = 10;		// geçerli
	printf("%d\n", r);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	R-Value referanslar sbaitlerle ya da başka türden nesnelerle ilkdeğer verilerek tanımlanabilirler. Bu durumda
	yine geçici nesnenin adresi referansa yerleştirilir. Ancak referans const olmak zorunda dğeildir.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int &&r = 10;			// geçerli
	
	printf("%d\n", r);		// 10
	r = 20;					// geçerli
	printf("%d\n", r);		// 20
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir fonksiyonun geri dönüş değeri bir referans olabilir. Bu durumda fonksiyon adeta return ifadesindeki
	nesneyi temsil ediyor durumdadır.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int g_a = 10;

int &foo()
{
	return g_a;
}

int main()
{
	foo() = 20;
	printf("%d\n", g_a);
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	new operatörünün kullanımı
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int *pi;

	pi = new int;		// 1 int'lik dinamik tahsisat

	*pi = 20;
	printf("%d\n", *pi);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	new operatörü
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int *pi;

	pi = new int[10];		// 10 int'lik dinamik tahsisat

	for (int i = 0; i < 10; ++i)
		pi[i] = i * i;

	for (int i = 0; i < 10; ++i)
		printf("%d\n", pi[i]);
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Eğer dinamik alan new operatörütünün köşeli parantezsiz versiyonuyla tahsis edilmişse delete operatörünün
	köşeli parantezsiz versiyonuyla boşaltılır. Eğer dinamik alan new operatörünün köşeli parantezli versiyonuyla
	tahsis edilmişse boşaltımı da köşeli parantezli delete operatörüyle yapılmalıdır.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	int *p1;
	int *p2;

	p1 = new int;
	p2 = new int[10];

	//....

	delete p1;
	delete[] p2;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	new ve delete operatörlerinin kullanımı
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getname()
{
	char s[100];
	char *name;

	printf("Adi Soyadi:");
	gets_s(s, 100);

	name = new char[strlen(s) + 1];
	strcpy(name, s);

	return name;
}

int main()
{
	char *name;

	name = getname();
	puts(name);

	delete[] name;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta parametrik yapıları farklı olan aynı isimli fonksiyonlar tanımlanabilir. Buna "function overloading"	
	denilmektedir.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void foo()
{
	printf("foo, void\n");
}

void foo(int a)		
{
	printf("foo, int\n");
}

void foo(long a)
{
	printf("foo, long\n");
}

void foo(double a)
{
	printf("foo, double\n");
}

int main()
{
	foo(10);
	foo(12.4);
	foo();
	foo(1L);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Overload resolution
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void print(int a, long b)		// #1
{
	printf("int, long\n");
}

void print(int a, double b)		// #2
{
	printf("int, double\n");
}

void print(double a, int b)		// #3
{
	printf("double, int\n");
}

void print(int a, int b)		// #4
{
	printf("int, int\n");
}

void print(int a, const char *str)	// #5
{
	printf("int, const char *\n");
}

void print()		// #6
{
	printf("void\n");
}

int main()
{
	print(100L, 1.2);		// int , double

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	overload resolution
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void print(int a, long b)		// #1
{
	printf("int, long\n");
}

void print(long a, int b)		// #2
{
	printf("int, double\n");
}

int main()
{
	print(100, 120);	// ambiguity error!

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta parametre değişkenleri default değer alabilir
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void foo(int a, int b = 10, int c = 20)
{
	printf("a = %d, b = %d, c = %d\n", a, b, c);
}

int main()
{
	foo(100);			// foo(100, 10, 20);
	foo(100, 200);		// foo(100, 200, 20);
	foo(100, 200, 300);	// foo(100, 200, 20);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Default argümanm alan parametre değişkenleri
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void putmsg(const char *msg = "ok")
{
	puts(msg);
}

int main()
{
	putmsg("error");
	putmsg();		// putmsg("ok");

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Default argüman alan fonlsiyonlar overload edildiğinde overload resolution sırasında ikianlamlılık (ambiguity)
	hataları ortaya çıkabilir
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

void foo(int a, int b = 10)		// imza: foo, int, ,nt
{
	printf("a = %d, b = %d\n", a, b);
}

void foo(int a)					// imza foo, int
{
	printf("a = %d\n");
}

int main()
{
	foo(10, 20);		// geçerli!
	foo(100);			// error!

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta bool türü vardır. Ayrıca C++'ta true ve false isminde bool türden iki sabit de vardır. 
	true 1 olarak, false ise 0 olarak aritmetik işlemlere sokulur.	
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	bool b = true;
	int result;

	result = true + 100;
	printf("%d\n", result);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta skaler türlerden bool türüne otomatik dönüştürme vardır. Sıfır dışı değerler true olarak, 
	0 değeri, NULL adres false olarak dönüştürülür.
---------------------------------------------------------------------------------------------------------*

#include <stdio.h>

int main()
{
	bool b = -3.7;		// b = true
	
	printf("%d\n", b);
	b = 0;				// b = false
	
	printf("%d\n", b);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	stdout dosyasına yazdırma yapmak için iostream kütüphanesindeki cout kullanımı	
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

int main(void)
{
	int a = 10, b = 20;

	cout << "a = " << a << ", " << b << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta enum türleri ayrı bir tür kabul edilmektedir ve temel türlerden enum türlerine otomatik dönüştürme 
	yoktur. enum türünün sabitleri ilgili enum türündendir. enum türünden değişkenlere ilgili enum'un 
	enum sabitleri atanabilir.
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

enum Color {
	Red, Green, Blue
};

int main(void)
{
	Color c = Green;
	cout << c << endl;

	c = 10;		// C'de geçerli, C++'ta geçersiz!

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Ancak enum türlerindne diğer temel türlere otomatik dönüştürme vardır. enum'un sayısal değeri işleme
	sokulur.
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

enum Color {
	Red, Green, Blue
};

int main(void)
{
	Color c = Green;
	int result;

	result = c;
	cout << result << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Ancak temel türlerdeki değrler tür dönüştürme operatörü ile enum türüne dönüştürülebilir
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

enum Color {
	Red, Green, Blue
};

int main(void)
{
	Color c;

	c = (Color)2;
	cout << c << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++11'de faaliyet alanı kısıtlanmış yeni bir enum türü daha dile eklenmiştir. Buna "scoped enumeration"
	denilmektedir. 
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

enum class Color {
	Red, Green, Blue
};

enum class Test {Red};

int main(void)
{
	Color c;
	Test t;

	t = Test::Red;
	c = Color::Red;

	cout << (int)c << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	inline fonksiyonlar
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

inline int square(int a)
{
	return a * a;
}

int main(void)
{
	cout << square(10) << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	inline fonksiyonlar static yapılmamışsa external linkage özelliği gösterirler
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

static inline int square(int a)
{
	return a * a;
}

int main(void)
{
	int result;

	result = square(10);		// result = 10 * 10

	cout << result << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıf bildirimi ve yapı bildirimi ileride görülecek basit bir fark dışında aynıdır. Ancak
	daha çok sınıflar kullanılır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
	//...
};

struct Mample {
	//...
};

int main(void)
{
	

	return 0;
}
/*--------------------------------------------------------------------------------------------------------
	Bir sınıfın 3 tane bölümü vardır. Bu bölümler erişim belirleyici anahtar sözcük ve : ile belirtilir.	
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	//public
private:
	//private
protected:
	//protected
};


int main(void)
{
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bölümlerden hepsi olmak zorunda değildir.
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	//public
private:
	//private
};


int main(void)
{
	

	return 0;
}
/*--------------------------------------------------------------------------------------------------------
	Sınıflarda istenildiği kadar bölüm belirtilebilir. Derleyici açısından aynı bölümler tek bir bölüm
	olarak ele alınır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	//public
private:
	//private
public:
	//...
private:
	//...
};


int main(void)
{
	

	return 0;
}
/*--------------------------------------------------------------------------------------------------------
	Bölüm belirtilmezse sınıflarda default private yapılarda ise default public bölüm kabul edilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
	//private
};

struct Mample {
	//public
};


int main(void)
{
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarına (member variable) nokta operatörü ile erişilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x; // Sınıfın veri elemanı
	double y; // 
};

int main(void)
{
	Sample s; //Nesne tanımlama

	s.x = 10;
	s.y = 3.5;

	Sample s2;

	s2.x = 34;
	s2.y = 4.6;

	cout << "s.x:" << s.x << "\n";
	cout << "s.y:" << s.y << "\n";

	cout << "s2.x:" << s2.x << "\n";
	cout << "s2.y:" << s2.y << "\n";

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonlarının sınıf dışında tanımlama genel sentaksı:
	<geri dönüş değeri> <sınıf ismi>::<fonksiyon ismi>([parametreler])
	{
		//...
	}
	Sınıfın üye fonksiyonlar sınıf nesnesi ve nokta operatörü ile çağrılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	void Foo();
	void Bar()
	{
		cout << "Bar\n";
	}
};

void Sample::Foo()
{
	cout << "Foo\n";
}


int main(void)
{
	Sample s;

	s.Foo();
	s.Bar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Fonksiyon türünden bir gösterici olabilir. Bu durumda elemanlara operatörü ile erişilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	void Foo();
	void Bar()
	{
		cout << "Bar\n";
	}
};

void Sample::Foo()
{
	cout << "Foo\n";
}


int main(void)
{
	Sample s;
	Sample *p;

	p = &s;

	(*p).Foo();
	(*p).Bar();

	p->Foo();
	p->Bar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfların const üye fonksiyonları olabilmektedir. Bu durumda const anahtar sözcüğü
	hem prototip bildirimnde hem de fonksiyon tanımlamasında olmalıdır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	void Foo() const;
	void Bar()
	{
		cout << "Bar\n";
	}
};

void Sample::Foo() const
{
	cout << "Foo\n";
}

int main(void)
{
	Sample s;

	s.Foo();
	s.Bar();


	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aynı isimde ve parametrik yapıya sahip hem const hem de const olmayan fonksiyon yazılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	void Foo() const;
	void Foo()
	{
		cout << "Foo\n";
	}
};

void Sample::Foo() const
{
	cout << "const Foo\n";
}

int main(void)
{
	Sample s;

	s.Foo();


	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const bir sınıf nesnesi ile sınıfın veri elemanlarına atama yapılamaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	double y;	
};


int main(void)
{
	Sample s1;
	const Sample s = s1;

	s1.x = 10;
	s.x = 10; //error

	

	
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanları mutable olarak bildirilebilir. Bu veri elemanlarına const 
	nesneler ile de atama yapılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	mutable double y;
};


int main(void)
{
	Sample s1;
	const Sample s = s1;

	s1.x = 10;
	s.y = 3.4;
	//s.x = 10; //error	
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const referanslar ile de sınıfın veri elemanlarına atama yapılamaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	mutable double y;
};


int main(void)
{
	Sample s;

	const Sample &r = s;

	r.x = 10; //error
	r.y = 4.5;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const göstericiler ile de sınıfın veri elemanlarına atama yapılamaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	mutable double y;
};


int main(void)
{
	Sample s;

	const Sample *p = &s;

	p->x = 10; //error
	p->y = 4.5;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıflar genel olarak veri elemanlarından ve bu elamanları kullanan üye fonksiyonlardan oluşur.
	Sınıfın üye fonskiyonları içerisinde veri elemanları doğrudan kullanılabilir. Bu durumda veri elemanı
	o fonksiyonun çağrıldığı nesnenin elemanı olur
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	void SetX(int a);
	void Disp()
	{
		cout << x << "\n";
	}
};

void Sample::SetX(int a)
{
	x = a;
}

int main(void)
{
	Sample s;

	s.SetX(20);	

	Sample s1;

	s1.SetX(34);

	s.Disp();
	s1.Disp();

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Sınıfın const üye fonksiyonları içerisinde sınıfın veri elemanları değiştirilemez
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	void Foo(int a) const
	{
		x = a; //error
	}
};

int main(void)
{
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const bir sınıf nesnesi ile (referans veye gösterici de olabilir) sınıfın const olmayan 
	üye fonksiyonları çağrılamaz. Çünkü const olmayan üye fonksiyon içerisinde sınıfın
	veri elemanı değiştiriliyor olabilir. Bu durum da const olma anlamıyla çelişir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	void Foo(int a)
	{
		
	}


};

int main(void)
{
	const Sample s;

	s.Foo(10);//error
	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir sınıfın üye fonksiyonu sınıfın veri elamanlarında değişiklik yapmıyorsa const olarak bildirilmelidir.
	(const bildirilmese de geçerlidir). Bu durumda const olmayan bir fonksiyon için kesinlikle veri elemanlarını
	değiştiriyordur (ya da değiştiren başka bir fonksiyonu çağırıyordur) denir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class IntNumber {
public:
	int val;
	void SetVal(int a)
	{
		val = a;
	}

	void Disp() const
	{
		cout << val << "\n";
	}

};

int main(void)
{
	IntNumber n;

	n.SetVal(20);
	n.Disp();	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir fonksiyonun parametresi const bir gösterici olabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class IntNumber {
public:
	int val;
	void SetVal(int a)
	{
		val = a;
	}

	void Add(short a)
	{
		Add((int)a);
	}

	void Add(int a)
	{
		val += a;
	}

	void Disp() const
	{
		cout << val << "\n";
	}

};

void Foo(const IntNumber *p)
{
	p->Disp();
}

int main(void)
{
	IntNumber n;

	n.SetVal(20);
	n.Add(10);
	Foo(&n);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Referans dönen fonkaiyonlar ile hem veri elemanını değiştirebilen hem de değerine erişilebildiği
	fonksiyonlar yazılabilir. Bu fonksiyonların const bir nesne, referans veya gösterici ile de
	çağrılabilmesi için aşağıdaki gibi overload edilmelidir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class IntNumber {
public:
	int val;
	int &value() 
	{
		cout << "int &value()\n";
		return val;
	}	
	const int &value() const 
	{
		cout << "const int &value() const\n";
		return val; 
	}
};

void Foo(const IntNumber &r)
{
	cout << r.value() << "\n";
}

int main()
{
	IntNumber n;

	n.value() = 45;

	cout << n.value() << "\n";

	Foo(n);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Referans dönen fonksiyonlar
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

int g_x;

int &foo()
{
	return g_x;
}

int main()
{
	int a;
	int &r = a;

	r = 10;

	cout << "a=" << a << "\n";

	foo() = 34;

	cout << "g_x=" << g_x << "\n";

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir sınıfın başlangıç fonskiyonları olabilir. Başlangıç fonskiyonları sınıf ismi ile aynı olan
	ve geri dönüş değeri kavramı olmayan fonskiyonlardır (void yazılamaz). Başlangıç fonskiyonları
	overload edilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	Sample() //default constructor
	{
		cout << "Sample::Sample()\n";
	}

	Sample(int val)
	{
		cout << "Sample::Sample(int)\n";
	}

	Sample(double val)
	{
		cout << "Sample::Sample(double)\n";
	}
};

int main()
{
	Sample s; 
	Sample s1(10);
	Sample s2(2.3);	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Standartlara göre bir sınıf için hiç bir constructor yazılmamışsa derleyici default constructor ı
	içi boş olarak yazar. Ancak programcı tarafından yazılan bir constructor varsa derleyici bu
	default constructor ı yazmaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int val)
	{
		cout << "Sample::Sample(int)\n";
	}

	Sample(double val)
	{
		cout << "Sample::Sample(double)\n";
	}
};

int main()
{
	Sample s; //error
	Sample s1(10);
	Sample s2(2.3);	

	return 0;
}
/*--------------------------------------------------------------------------------------------------------
	Constructor içerisinde sınıfın veri elemanlarına değer atanabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Date {
public:
	int day, mon, year;

	Date(int d, int m, int y)
	{
		//...
		day = d;
		mon = m;
		year = y;
	}

	void Disp() const
	{
		cout << day << "/" << mon << "/" << year << "\n";
	}
};

int main()
{
	Date d(10, 9, 1976);

	d.Disp();
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Constructor içerisinde nesnenin yaratılması sırasında birtakım ilk işlemler yapılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

class File {
public:
	FILE *f;

	File(const char *fname, const char *mode)
	{
		if ((f = fopen(fname, mode)) == NULL) {
			cerr << "Can not open file:" << fname;
			exit(EXIT_FAILURE);
		}
	}

	void Type() const
	{
		int ch;

		while ((ch = fgetc(f)) != EOF)
			putchar(ch);
	}
	//...
};

int main()
{	
	File file("test.txt", "r");

	file.Type();
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın public bölümü her yerden erişilebilrdir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int x;
	void Foo()
	{
		//...
	}
};

int main()
{	
	Sample s;

	s.Foo();
	s.x;	
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın private bölümü yalnızca sınıf içerisinden erişilebillir bölümdür
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
private:
	int x;
	void Foo()
	{
		x = 10;
		//...
	}

	void Bar();
};

void Sample::Bar()
{
	x = 34;
	Foo();
}

int main()
{	
	Sample s;

	s.Foo(); //error
	s.x;	//error
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfın protected bölümü türetme (inheritance) sözkonusu değilse private anlamındadır.
	Inheritance konusu ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
protected:
	int x;
	void Foo()
	{
		x = 10;
		//...
	}

	void Bar();
};

void Sample::Bar()
{
	x = 34;
	Foo();
}

int main()
{	
	Sample s;

	s.Foo(); //error
	s.x;	//error
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Sınıfların bölümleri
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Date {
public:
	Date(int day, int mon, int year);
public:
	void SetDay(int day);
	void SetMonth(int mon);
	void SetYear(int year);
	int GetDay() const { return m_day; }
	int GetMonth() const { return m_mon; }
	int GetYear() const { return m_year; }
private:
	int m_day, m_mon, m_year;
};


Date::Date(int day, int mon, int year)
{
	//...
	m_day = day;
	m_mon = mon;
	m_year = year;
}

void Date::SetDay(int day)
{
	//...
	m_day = day;
}
void Date::SetMonth(int mon)
{
	//...
	m_mon = mon;
}
void Date::SetYear(int year)
{
	//...
	m_year = year;
}

int main()
{	
	Date d(10, 9, 1976);

	cout << d.GetDay() << "/" << d.GetMonth() << "/" << d.GetYear() << endl;

	d.SetDay(11);
	d.SetMonth(7);
	d.SetYear(1983);

	cout << d.GetDay() << "/" << d.GetMonth() << "/" << d.GetYear() << endl;
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Encapsulation durumu ile karşılabilecek durumlar:
	1. Sınıfların veri elemanlarının sınıflar geliştirildikçe isimlerinin ve hatta türlerinin
	değiştirilmesi çok sık rastlan bir durumdur. Bçyle bir durumda eski kodların da bundan etkilenmemesi
	için veriler gizlenebilir
	2. Bir veri elemanının sınır değerleri olabilir. Örneğin bir veri elemanının negatif olmaması
	gerekiyorsa dışarıdan yapılacak olan geçersiz atamaların engellenebilmesi ve kontrollü
	bir biçimde yapılabilmesi veriler gizlenebilir
	3. Bir veri elemanı değiştiğinde başka bir veri elemanın da değiştirilmesi gerekebilir. Bu durumun
	yapılması için veriler gizlenebilir
	4. Bir veri elemanı değiştiğinde sınıfın bir işlem yapıyor olması gerekebilir. Bu durumda da
	veriler gizlenebilir
---------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------
	M.I.L (Member initialization list), ctor sentaksı
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x) : m_x(x)
	{}
	int GetX() const { return m_x; }
private: 
	int m_x;
};


#if 1
int main()
{	
	Sample s(10);

	cout << s.GetX() << endl;
	
	
	return 0;
}
#endif



/*--------------------------------------------------------------------------------------------------------
	Date sınıfı iskeleti
---------------------------------------------------------------------------------------------------------*/

#ifndef DATE_H_
#define DATE_H_

class Date {
public:
	Date(int day, int mon, int year);
public:
	void SetDay(int day);
	void SetMonth(int mon);
	void SetYear(int year);
	int GetDay() const { return m_day; }
	int GetMonth() const { return m_mon; }
	int GetYear() const { return m_year; }
	int GetDayOfYear() const { return m_dayOfYear; }
private:
	int m_day, m_mon, m_year;
	int m_dayOfYear;
};


#endif //DATE_H_
#include "Date.h"

Date::Date(int day, int mon, int year)
{
	//...
	m_day = day;
	m_mon = mon;
	m_year = year;
}

void Date::SetDay(int day)
{
	//...
	m_day = day;
}
void Date::SetMonth(int mon)
{
	//...
	m_mon = mon;
}
void Date::SetYear(int year)
{
	//...
	m_year = year;
}

#if 0
#include <iostream>

using namespace std;

int main()
{
	Date d(10, 9, 1976);

	cout << d.GetDay() << "/" << d.GetMonth() << "/" << d.GetYear() << endl;

	d.SetDay(11);
	d.SetMonth(7);
	d.SetYear(1983);

	cout << d.GetDay() << "/" << d.GetMonth() << "/" << d.GetYear() << endl;


	return 0;
}

#endif



/*--------------------------------------------------------------------------------------------------------
	File sınıfının iskeleti
---------------------------------------------------------------------------------------------------------*

#ifndef FILE_H_
#define FILE_H_

#include <iostream>
#include <cstdio>
#include <cstdlib>

class File {
public:
	File(const char *fname, const char *mode);	
	void Type() const;	
	//...
private:
	FILE *m_f;
};

#endif // FILE_H_
#include "File.h"

File::File(const char *fname, const char *mode)
{
	if ((m_f = fopen(fname, mode)) == NULL) {
		std::cerr << "Can not open file:" << fname;
		exit(EXIT_FAILURE);
	}
}

void File::Type() const
{
	int ch;

	while ((ch = fgetc(m_f)) != EOF)
		putchar(ch);
}


#if 0

#include <iostream>

int main()
{
	File f("test.txt", "rt");

	f.Type();

	return 0 ;

}
#endif

/*--------------------------------------------------------------------------------------------------------
	Basit bir Circle sınıfı
---------------------------------------------------------------------------------------------------------*
#ifndef CIRCLE_H_
#define CIRCLE_H_

class Circle {
public:
	Circle(double r = 0.0);
	void SetRadius(double r);
	double GetRadius() const { return m_r; }
	double GetArea() const { return m_area; }
	double GetCircumference() const { return m_circumference; }
private:
	void calculate();
private:
	double m_r;
	double m_area, m_circumference;
};


#endif

#include "Circle.h"

#include <cmath>

using namespace std;

static const double PI = 3.14;

void Circle::calculate()
{
	m_area = PI * m_r * m_r;
	m_circumference = 2 * PI * m_r;
}

Circle::Circle(double r) : m_r(fabs(r))
{
	calculate();
}

void Circle::SetRadius(double r)
{
	m_r = fabs(r);
	calculate();
}

#if 0

#include <iostream>

void Display(const Circle &r)
{
	cout << "Radius:" << r.GetRadius() << endl;
	cout << "Circumference:" << r.GetCircumference() << endl;
	cout << "Area:" << r.GetArea() << endl;	
}

int main()
{
	Circle c(-3.4);

	Display(c);

	c.SetRadius(4.6);

	Display(c);

	return 0;
}

#endif





/*--------------------------------------------------------------------------------------------------------
	
---------------------------------------------------------------------------------------------------------*
#ifndef CIRCLE_H_
#define CIRCLE_H_

class Circle {
public:
	Circle(double r = 0.0);
	void SetRadius(double r);
	double GetRadius() const { return m_r; }
	double GetArea() const;
	double GetCircumference() const;
private:
	void calculate();
private:
	double m_r;	
};


#endif

#include "Circle.h"

#include <cmath>

using namespace std;

static const double PI = 3.14;

Circle::Circle(double r) : m_r(fabs(r))
{}
void Circle::SetRadius(double r)
{
	m_r = fabs(r);	
}

double Circle::GetArea() const
{
	return PI * m_r * m_r;
}
double Circle::GetCircumference() const
{
	return 2 * PI * m_r;
}

#if 1

#include <iostream>

void Display(const Circle &r)
{
	cout << "Radius:" << r.GetRadius() << endl;
	cout << "Circumference:" << r.GetCircumference() << endl;
	cout << "Area:" << r.GetArea() << endl;	
}

int main()
{
	Circle c(-3.4);

	Display(c);

	c.SetRadius(4.6);

	Display(c);

	return 0;
}

#endif
/*--------------------------------------------------------------------------------------------------------
	Sınıfların bitiş fonksiyonu (destructor) nesnenin ömrü bittiğinde otomatik olarak çağrılan fonksiyondur
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x) : m_x(x)
	{
		cout << "constructor:m_x=" << m_x << "\n";
	}

	~Sample()
	{
		cout << "destructor m_x=" << m_x << "\n";
	}
private:
	int m_x;
};

#if 1
int main()
{	
	Sample s(10);
	Sample s1(20);
	
	return 0;
}
#endif
/*--------------------------------------------------------------------------------------------------------
	Destructor içerisinde sınıf nesnesi yapılacak kritik işlemlerin nesne öldüğünde yapılması
	sağlanabilir. Örneğin bir sınıf içerisinde dinamik olarak tahsis edilmiş bir alan
	delete edilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	Sample(size_t n) : m_p(new int[n])
	{}
	//...
	~Sample() { delete[] m_p; }
private:
	int *m_p;
};

#if 1
int main()
{	
	Sample s(10);
	Sample s1(20);
	
	return 0;
}
#endif


/*--------------------------------------------------------------------------------------------------------
	
---------------------------------------------------------------------------------------------------------*
#ifndef FILE_H_
#define FILE_H_

#include <iostream>
#include <cstdio>
#include <cstdlib>

class File {
public:
	File(const char *fname, const char *mode);	
	~File() { fclose(m_f); }
	void Type() const;	
	//...
private:
	FILE *m_f;
};

#endif // FILE_H_
#include "File.h"

File::File(const char *fname, const char *mode)
{
	if ((m_f = fopen(fname, mode)) == NULL) {
		std::cerr << "Can not open file:" << fname;
		exit(EXIT_FAILURE);
	}
}

void File::Type() const
{
	int ch;

	while ((ch = fgetc(m_f)) != EOF)
		putchar(ch);
}


#if 0

#include <iostream>

int main()
{
	File f("test.txt", "rt");

	f.Type();

	return 0 ;

}
#endif

/*--------------------------------------------------------------------------------------------------------
	new operatörü ile dinamik olarak nesne tahsisatı da yapılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:	
	Sample(size_t n = 10) : m_p(new int[n])
	{}
	//...
	~Sample() { delete[] m_p; }
private:
	int *m_p;
};

#if 1
int main()
{	
	Sample *p;

	p = new Sample; // a = new Sample();

	delete p;
	
	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	new operatörü ile dinamik olarak nesne tahsisatı da yapılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:	
	Sample(size_t n = 10) : m_p(new int[n])
	{}
	//...
	~Sample() { delete[] m_p; }
private:
	int *m_p;
};

#if 1
int main()
{	
	Sample *p;

	p = new Sample(12);

	delete p;
	
	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	Sınıf türünden diziler olabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:	
	Sample(size_t n = 10) : m_p(new int[n])
	{}
	//...
	~Sample() { delete[] m_p; }
private:
	int *m_p;
};

#if 1
int main()
{	
	Sample *p = new Sample[10];
	Sample samples[20];

	delete[] p;

	return 0;
}
#endif
/*--------------------------------------------------------------------------------------------------------
	Composition (has a) ilişkisi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class B {
public:
	B(/*...*/)
	{
		cout << "B constructor\n";
	}

	~B()
	{
		cout << "B destructor\n";
	}
};

class A {
public:
	A(/*...*/)
	{
		cout << "A constructor\n";
	}
	~A()
	{
		cout << "A destructor\n";
	}
private:
	B m_b;
};

#if 1
int main()
{	
	A a;
	
	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	Kapsanan sınıfının istenilen bir constructorı ctor sentaksı ile çağrılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class B {
public:
	B()
	{
		cout << "B constructor\n";
	}
	B(int a)
	{
		cout << "B constructor int\n";
	}

	~B()
	{
		cout << "B destructor\n";
	}
};

class A {
public:
	A(/*...*/) : m_b(10)
	{
		cout << "A constructor\n";
	}
	~A()
	{
		cout << "A destructor\n";
	}
private:
	B m_b;
};

#if 1
int main()
{	
	A a;
	
	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	Composition ilişkisinin kapsayan bir referans tutularak gerçekleştirimi
	Dikkat, bazı ayrıntılar (copy constructor, move constructor vs.) yazılmamıştır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class B {
public:
	B()
	{
		cout << "B constructor\n";
	}
	B(int a)
	{
		cout << "B constructor int\n";
	}

	~B()
	{
		cout << "B destructor\n";
	}
};

class A {
public:
	A(/*...*/) : m_p(new B(10))
	{
		cout << "A constructor\n";
	}
	~A()
	{
		delete m_p;
		cout << "A destructor\n";
	}
private:
	B *m_p;
};

#if 1
int main()
{	
	A a;
	
	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	Car ile Engine arasındaki composition ilişkisi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstring>

using namespace std;

class Engine {
public:
	Engine(const char *pt, int tork);
	//...
	const char *GetType() const { return m_type; }
	int GetTork() const { return m_tork; }
	//...
public:
	void Start();
	void Accelerate();
	void Slow();
	void Stop();
	//...
private:
	char m_type[50];
	int m_tork;
};

Engine::Engine(const char *type, int tork) : m_tork(tork)
{
	strcpy(m_type, type);
}

void Engine::Start()
{
	cout << "Start engine" << endl;
}
void Engine::Accelerate()
{
	cout << "Accelerate engine" << endl;
}

void Engine::Slow()
{
	cout << "Slow engine" << endl;
}

void Engine::Stop()
{
	cout << "Stop engine" << endl;
}

class Car {
public:
	Car(int count, const char *model, const char *type, int tork) 
		: m_count(count), m_engine(type, tork)
	{
		strcpy(m_model, model);
	}
	//...
public:
	void Run();
	void Brake();
private:
	int m_count;
	char m_model[50];
	Engine m_engine;
};

void Car::Run()
{
	m_engine.Start();
	m_engine.Accelerate();
	//...
	Brake();
	m_engine.Stop();	
}
void Car::Brake()
{
	m_engine.Slow();
}



#if 1
int main()
{	
	Car c(4, "Ferrari", "Diesel", 350);

	c.Run();
	
	return 0;
}
#endif
/*--------------------------------------------------------------------------------------------------------
	Aggregation (holds a) ilişkisinin genel biçimi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>


using namespace std;

class B {

};

class A {
public:
	A(B *p/*, ...*/) :
		m_p(p)/*, ...*/
	{}
	void setB(B *p)
	{
		m_p = p;
	}
	B *GetB() const { return m_p; }
private:
	B *m_p;
};
#if 1
int main()
{	
	B b;
	A a(&b);
	B b1;
	a.setB(&b1);

	return 0;
}
#endif

/*--------------------------------------------------------------------------------------------------------
	Connection ile Command arasındaki basit bir aggregation ilişkisi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstring>

using namespace std;

class Connection {
public:
	Connection(const char *url, const char *username, const char *password)
	{
		strcpy(m_url, url);
		strcpy(m_username, username);
		strcpy(m_password, password);
	}

	//...
	const char *GetUrl() const { return m_url; }
	const char *GetUsername() const { return m_username; }
	const char *GetPassword() const { return m_password; }
private:
	char m_url[250];
	char m_username[50];
	char m_password[50];
};

class Command {
public:
	Command(Connection *p, const char *cmd) : m_p(p)
	{
		strcpy(m_cmd, cmd);
	}
	//...
public:
	void Execute()
	{
		cout << "Url:" << m_p->GetUrl() << "\n";
		cout << "Username:" << m_p->GetUsername() << "\n";
		cout << "Password:" << m_p->GetPassword() << "\n";
		cout << "Command:" << m_cmd << "\n";
	}
private:
	Connection *m_p;
	char m_cmd[500];
};

#if 1
int main()
{	
	Connection con("mysql://189.78.98:3306/peopledb", "oguz", "1234");
	const char *cmdStr = "select * from people";
	Command cmd(&con, cmdStr);

	cmd.Execute();

	return 0;
}
#endif


/*--------------------------------------------------------------------------------------------------------
	İsim alanları global bölgedeki isim çakışmasını bir nebze olsun engellemek için düşünülmüştür		
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	class Sample {
		//...
	};

	int x;

	void foo()
	{
		cout << "A::foo" << endl;
	}
}

namespace B
{
	class Sample {
		//...
	};

	int x;

	void foo()
	{
		cout << "B::foo" << endl;
	}
}

int main()
{
	A::Sample s;
	B::Sample k;

	A::x = 10;
	B::x = 20;

	cout << A::x << ", " << B::x << endl;

	A::foo();
	B::foo();


	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	İç içe isim alanları söz konusu olabilir. 
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	int a;
	namespace B
	{
		int b;
	}
}

int main()
{
	A::a = 10;
	A::B::b = 20;


	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir fonksiyonun prototip bildirimi bir isim alanında yapılabilir. Tanımlaması ise onu kapsayan bir 
	isim alanında yapılabilir
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	void foo();
}

void A::foo()
{
	cout << "A::foo" << endl;
}

int main()
{
	A::foo();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
		Bir fonksiyonun prototip bildirimi bir isim alanında yapılabilir. Tanımlaması ise onu kapsayan bir 
	isim alanında yapılabilir
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	namespace B
	{
		void foo();
	}

	void B::foo()
	{
		cout << "A::foo" << endl;
	}
}

int main()
{
	A::B::foo();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ın bütün sınıfları ve fonksiyonları ve nesneleri (tüm isimleri) std isim alanın içerisindedir
---------------------------------------------------------------------------------------------------------*

#include <iostream>

int main()
{
	std::cout << "merhaba" << std::endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aynı isim alanı birden fazla kez bildirilebilir. Bu durum ekleme anlamına gelir.
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	void foo()
	{
		cout << "foo\n";
	}
}

namespace A 
{
	void bar()
	{
		cout << "bar\n";
	}
}
	
int main()
{
	A::foo();
	A::bar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	using naespace direktifi	
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

namespace A
{
	namespace B {
		void foo()
		{
			cout << "A::foo" << endl;
		}
	}

	using namespace B;

	void bar()
	{
		foo();
	}
}


int main()
{
	A::foo();
	B::bar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Eğer isim aranırken birden fazla using direktifi ile belirtilen isim alanında bulunursa error oluşur
---------------------------------------------------------------------------------------------------------*

#include <iostream>

namespace A
{
	void foo()
	{
		//...
	}
}

namespace B {
	void foo()
	{
		//...
	}
}

using namespace A;
using namespace B;

int main()
{
	foo();		// error!

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte A ve B isim alanlarını kapsayan en dar isim alanı global isim alanıdır. Dolayısıyla
	çağrıda bir sorun ortaya çıkmaz.
---------------------------------------------------------------------------------------------------------*

#include <iostream>

namespace A
{
	void foo()
	{
		//...
	}
}

namespace B
{
	using namespace A;

	void foo()
	{
		//...
	}

	void bar()
	{
		foo();
	}
}

int main()
{
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Geçici nesnelerinn yaratılması
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "constructor" << endl;
	}

	Sample(int a)
	{
		cout << "int constructor" << endl;
		m_a = a;
	}
	
	~Sample()
	{
		cout << "destructor" << endl;
	}

	void disp() const
	{
		cout << m_a << endl;
	}
private:
	int m_a;
};

void foo(const Sample &s)
{
	s.disp();
}

int main()
{
	foo(Sample(10));

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Geçici nesne const bir referansa bağlanışsa bu durumda onun yok edilmesi referansın faaliyet alanı 
	bittiğinde yapılmaktadır.
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "constructor" << endl;
	}

	Sample(int a)
	{
		cout << "int constructor" << endl;
		m_a = a;
	}
	
	~Sample()
	{
		cout << "destructor" << endl;
	}

	void disp() const
	{
		cout << m_a << endl;
	}
private:
	int m_a;
};

void foo(const Sample &s)
{
	s.disp();
}

int main()
{
	{
		const Sample &s = Sample();
		cout << "one" << endl;
	}
	cout << "two" << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta türetme işlemleri
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class A {
public:
	void foo();
	void bar();
private:
	int m_x;
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

class B : public A {
public:
	void tar();
};

void B::tar()
{
	cout << "B::tar" << endl;
}

int main()
{
	B b;

	b.foo();
	b.bar();
	b.tar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesi taban sınıfın veri elemanlarını da tutar
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class A {
public:
	void foo();
	void bar();
private:
	int m_x;
	int m_y;
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

class B : public A {
public:
	void tar();
private:
	int m_z;
	int m_k;
};

void B::tar()
{
	cout << "B::tar" << endl;
}

int main()
{
	B b;

	cout << sizeof(b) << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Türetme Durumunda başlangıç ve bitiş fonksiyonlarının çağrılması
---------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class A {
public:
	A();
	A(int a);
	~A();
private:
	int m_a;
};

class B : public A {
public:
	B(int a, int b);
	~B();
private:
	int m_b;
};

class C : B {
public:
	C(int a, int b, int c);
	~C();
private: 
	int m_c;
};

A::A()
{
	cout << "default constructor\n";
}

A::A(int a) 
{
	cout << "A int constructor\n";
	m_a = a;
}

A::~A()
{
	cout << "A destructor\n";
}


B::B(int a, int b) : A(a)
{
	cout << "B int, int constructor\n";
	m_b = b;
}

B::~B() 
{
	cout << "B destructor\n";
}

C::C(int a, int b, int c) : B(a, b)
{
	cout << "C int, int, int consturctor\n";
	m_c = c;
}

C::~C()
{
	cout << "C desctructor\n";
}

int main()
{
	C c(1, 2, 3);

	return 0;
}

#include <iostream>

class Base {
	//interface
protected:

public:
	void func();
	void foo();

};

class Der : public Base {
public:
	void derf();
};

int main()
{
	Der myder;

	myder.func();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

class Base {
public:
	void func(int);
};

class Der : public Base {
public:
	void func(double);
};

int main()
{
	Der myder;

	myder.func(12); //Der::func(double);
}
//--------------------------------------------------
//--------------------------------------------------

class Base {
public:
	void func(double);
};

class Der : public Base {
	void func(int);
public:
};

int main()
{
	Der myder;

	myder.func(1.2); //error --->  access control
}
//--------------------------------------------------
//--------------------------------------------------
class Base {
public:
	void func(double);
};

class Der : public Base {
	void func(int);
public:
};

int main()
{
	Der myder;

	myder.Base::func(1.2);
}
//--------------------------------------------------
//--------------------------------------------------

class Myclass {
public:
	void func(double);
};


int main()
{
	Myclass m;

	m.func(12.5);
	m.Myclass::func(12.4);
}
//--------------------------------------------------
//--------------------------------------------------

class Base {
	//int x;
public:
	void func(double);
};

int x = 10;

class Der : public Base {
	//int x;
public:
	void foo()
	{
		//int x = 10;
		int a = x;
	}
};

int main()
{

}
//--------------------------------------------------
//--------------------------------------------------

class Base {
public:
	int x;

	void func(double);
};

int x = 10;

class Der : public Base {
	int x;
public:
	void foo()
	{
		int x = 10;
		int a = x; //x in block
		int b = Der::x; //x in Der class
		int c = Base::x; //x in Base class
		int d = ::x; //global x

	}
};

int main()
{

}
//--------------------------------------------------
//--------------------------------------------------

class Base {
	int x;

public:

	void func(double);
};

int x = 10;

class Der : public Base {
	int x;
public:
	void foo()
	{
		int x = 10;
		int a = x; //x in block
		int b = Der::x; //x in Der class
		int c = Base::x; //x in Base class - gecersiz access control
		int d = ::x; //global x

	}
};

int main()
{

}
//--------------------------------------------------
//--------------------------------------------------

class Base {
	int x;
public:
	void func(int);
};


class Der : public Base {
	int x;
public:
	void func(double);
	void foo()
	{
		func(12);  //Der::func
		Base::func(12.5);  //Base::func
	}
};

int main()
{

}
//--------------------------------------------------
//--------------------------------------------------

class Base {
	int x;
public:
	void foo(int);
};


class Der : public Base {
	int x;
public:
	void foo()
	{
		//foo(12);  //gecersiz -----> arguman sayısı parametre deg. sayisi uyumsuzlugu
		foo();  //gecerli recursive call
		Base::foo(12); //Base::foo(int)
	}
};

int main()
{

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Base {
	int x, y;
};

class Der : public Base {
	int z;
};

int main()
{
	std::cout << "sizeof (Base) = " << sizeof(Base) << std::endl;
	std::cout << "sizeof (Der) = " << sizeof(Der) << std::endl;


	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Base {
public:
	Base()
	{
		std::cout << "Base::Base()" << std::endl;
	}
};


class Der : public Base {
public:

};

int main()
{
	Der myder;


	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Base {
public:
	Base()
	{
		std::cout << "Base::Base()" << std::endl;
	}
};


class Der : public Base {
public:
	Der() 
	{
		std::cout << "Der::Der()" << std::endl;
	}

};

int main()
{
	Der myder;


	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Base {
public:
	Base(int)
	{
		std::cout << "Base::Base(int)" << std::endl;
	}
};


class Der : public Base {
public:
};

int main()
{
	//Der myder;  //attempting to reference a deleted function

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------
		
copy constructor
kopyalayan kurucu işlev

Myclass m1;

Myclass m2 = m1;
Myclass m3(m1);

------------------------------------
void func(Myclass x);


{
	Myclass m;
	func(m);

------------------------------------
Myclass func()
{
	Myclass m;
	//code

	return m;
}

Bir sınıf için copy constructor yazmaz isek derleyici sınıfımız için
-non static
- public
- inline

bir copy ctor yazar ve derleyicinin yazdığı copy ctor aşağıdaki parametrik yapıdadır:

class Myclass {
	T1 t1;
	T2 t2;
	T3 t3;
public:
	//compiler generated copy ctor
	Myclass(const Myclass &r) : t1(r.r1), t2(r.t2), t3(r.t3)
	{
	
	}

};


#include <iostream>

class Myclass {
	int mx, my;
public:
	Myclass() : mx(0), my(0) {	}
	Myclass(int x, int y) : mx(x), my(y) {}
	void print()const
	{
		std::cout << "mx = " << mx << " my = " << my << "\n";
	}

};


int main()
{
	Myclass m1(12, 78);
	m1.print();
	Myclass m2 = m1;  //m2 icin derleyici tarafindan yazilan copy ctor cagrilacak
	m2.print();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Myclass {
	int mx, my;
public:
	Myclass() : mx(0), my(0) {	}
	Myclass(int x, int y) : mx(x), my(y) {}
	//Myclass(const Myclass &r) : mx(r.mx), my(r.my) {} //compiler generated copy ctor
	void print()const
	{
		std::cout << "mx = " << mx << " my = " << my << "\n";
	}

};


int main()
{
	Myclass m1(12, 78);
	m1.print();
	Myclass m2 = m1;  //m2 icin derleyici tarafindan yazilan copy ctor cagrilacak
	m2.print();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Myclass {
	int mx, my;
public:
	Myclass() : mx(0), my(0) {	}
	Myclass(int x, int y) : mx(x), my(y) {}

	Myclass(const Myclass &r) : mx(r.mx), my(r.my)
	{
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
	}

	void print()const
	{
		std::cout << "mx = " << mx << " my = " << my << "\n";
	}

};


int main()
{
	Myclass m1(12, 78);
	m1.print();
	Myclass m2 = m1;  //m2 icin derleyici tarafindan yazilan copy ctor cagrilacak
	m2.print();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Myclass {
	int mx, my;
public:
	Myclass() : mx(0), my(0) {	}
	Myclass(int x, int y) : mx(x), my(y) {}

	Myclass(const Myclass &r) : mx(r.mx), my(r.my)
	{
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
	}

	void print()const
	{
		std::cout << "mx = " << mx << " my = " << my << "\n";
	}

};


void func(Myclass m)
{
	std::cout << "func()" << std::endl;
}

int main()
{
	Myclass m1(12, 78);

	func(m1);

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

class Myclass {
	int mx, my;
public:
	Myclass() : mx(0), my(0) {	}
	Myclass(int x, int y) : mx(x), my(y) {}

	Myclass(const Myclass &r) : mx(r.mx), my(r.my)
	{
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
	}

	void print()const
	{
		std::cout << "mx = " << mx << " my = " << my << "\n";
	}

};


Myclass gm;

Myclass func()
{
	//code
	return gm;
}

int main()
{
	func();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

this pointer ve (this anahtar sözcüğü)

class Myclass {
	
	x;  //x Myclass definition içinde bildirilen bir isim olsun

};


-------------------------------------
data member
	static data member
	non-static data member

member function
	static member function
	non-static member function

member type


class Myclass {
	int mx; //non static data member
	static int ms; //static data member
public:
	void func(); //non-static member function
	static void foo(int); //static member function

	class A {     //type member ---> member type ---> nested type
		//
	};

};



#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func()
	{
		std::cout << "this = " << this << std::endl;
	}
};


int main()
{
	Myclass m;

	std::cout << "&m   =  " << &m << std::endl;

	m.func();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func()
	{
		std::cout << "this = " << this << std::endl;
		//this = bu işlev hangi nesne için çağrılmışsa o nesnenin adresi

		//*this = bu işlev hangi nesne için çağrılmışsa o nesnenin kendisi
	}
};


int main()
{
	Myclass m;

	std::cout << "&m   =  " << &m << std::endl;

	m.func();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func()
	{
		mx = 10;
		this->mx = 10;
		Myclass::mx = 10;
		///yukaridaki 3 atama da aynı anlamda
	}
};


int main()
{
	Myclass m;

	std::cout << "&m   =  " << &m << std::endl;

	m.func();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func()
	{
		//bu işlev hangi nesne için çağrılmış ise o nesnenin adresini global bir işleve göndermek
		//bu işlev hangi nesne için çağrılmış ise o nesnenin kendisini global bir işleve göndermek
	}

	Myclass &foo()
	{
		//bu işlev hangi nesne için çağrılmış ise o nesnenin kendisini döndürmek
	}

	Myclass *f()
	{
		//bu işlev hangi nesne için çağrılmış ise o nesnenin adresini döndürmek
	}


};


int main()
{

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func();
};

//myclass.cpp

void gf1(Myclass *ptr);
void gf2(Myclass &r);

void Myclass::func()
{
	gf1(this);
	gf2(*this);
}

//client.cpp
int main()
{
	Myclass m;
	m.func();
	return 0;
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	Myclass *func()
	{
		///code
		return this;
	}

	Myclass &foo()
	{
		//code
		return *this;
	}
};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


void A::func()
{

}


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	Myclass func()
	{
		Myclass m;

		//this = &m; sentaks hatasi
		//this kendisi const olan bir pointer
		//üye işlv içinde this göstericisinin değerini  değiştiremeyiz.
	}
};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func(/* const Myclass *const this */) const
	{
		
	}

	void foo(/* Myclass *const this */) 
	{

	}
};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	Myclass *foo()
	{
		//
		return this;
	}

	//Myclass *func()const
	//{
	//	//
	//	//return this;  gecersiz
	//}

	const Myclass *f()const
	{
		//
		return this;  
	}
};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void foo(int x);
	void func()
	{
		mx = 10;
		this->mx = 10;

		foo(20);
		this->foo(20);
	}

};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void foo(int x);
	void func()
	{
		int mx = 23;

		mx = 50;  //yerel mx
		this->mx = 30; //Myclass::mx;
		Myclass::mx = 40; //Myclass::mx;
	}

};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------


#include <iostream>

using namespace std;

class Myclass {
	int mx;
public:
	void func()
	{
		mx = 10;
		this->mx = 10;
		Myclass::mx = 45;

	}

};


//client.cpp
int main()
{
}
//--------------------------------------------------
//--------------------------------------------------



//myclass.h

class Myclass {
	int mx;  //mx is a non-static data member of class Myclass
	static int sx;  //sx is a static data member of class Myclass
	//declaration only
};

//myclass.cpp

int Myclass::sx = 0;  //definition

//--------------------------------------------------
//--------------------------------------------------
Tek Nesne Örüntüsü

singleton implemantasyonu
singleton bir OOP tasarım kalıbıdır. Çok sık kullanılır.
Bir sınıf türünden yalnızca tek bir nesne olacak.
İKinci bir sınıf nesnesinin oluşturulmasına izin verilemeyeck.
Tek nesneye global bir erişim sağlanacak



class Singleton {
	Singleton();
	static Singleton *mp;
public:
	static Singleton &getInstance()
	{
		if (!mp)
			mp = new Singleton;

		return *mp;

	}
	int get()const;
	void set(int x);
	void print()const;
};
///

Singleton * Singleton::mp = 0;


int main()
{
	Singleton::getInstance().print();
	Singleton &rs = Singleton::getInstance();

	int ival = rs.get();
	rs.set(10);
	rs.print();
	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

///name.h
#define _CRT_SECURE_NO_WARNINGS

#include <cstring>
#include <iostream>

class Name {
	int mlen;
	char *mp;
public:
	Name(const char *p) : mlen(strlen(p)), mp(new char[mlen + 1])
	{
		strcpy(mp, p);
	}
	~Name()
	{
		delete[]mp;
	}
	void print()const
	{
		std::cout << "(" << mp << ")" << std::endl;
	}
	int getLength()const
	{
		return mlen;
	}
	void set(int idx, int c)
	{
		mp[idx] = c;
	}
};





//client.cpp
int main()
{
	Name name1 = "mustafa aksoy";
	name1.print();
	int len = name1.getLength();
	name1.set(8, 'O');
	name1.print();


	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

///name.h
#define _CRT_SECURE_NO_WARNINGS

#include <cstring>
#include <iostream>

class Name {
	int mlen;
	char *mp;
public:
	Name(const char *p) : mlen(strlen(p)), mp(new char[mlen + 1])
	{
		strcpy(mp, p);
	}
	Name(const Name &r) : mlen(r.mlen), mp(new char[mlen + 1])
	{
		strcpy(mp, r.mp);
	}
	Name &operator=(const Name &r)
	{
		mlen = r.mlen;
		delete[]mp;
		mp = new char[mlen + 1];
		strcpy(mp, r.mp);
		return *this;
	}

	~Name()
	{
		delete[]mp;
	}
	void print()const
	{
		std::cout << "(" << mp << ")" << std::endl;
	}
	int getLength()const
	{
		return mlen;
	}
	void set(int idx, int c)
	{
		mp[idx] = c;
	}
};


void gfunc(Name p)
{
	std::cout << "gfunc cagrildi \n";
	p.print();
}


//client.cpp
int main()
{
	Name name1 = "mustafa aksoy";
	name1.print();

	if (true) {
		Name name2 = "gizem ersoz";
		name2.print();
		name2 = name1;
		name2.print();
	}
	getchar();
	name1.print();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

///name.h
#define _CRT_SECURE_NO_WARNINGS

#include <cstring>
#include <iostream>

class Name {
	int mlen;
	char *mp;
	Name &deepCopy(const Name &r)
	{
		mlen = r.mlen;
		mp = new char[mlen + 1];
		strcpy(mp, r.mp);
		return *this;
	}
	void releaseResources()
	{
		delete[]mp;
	}

public:
	Name(const char *p) : mlen(strlen(p)), mp(new char[mlen + 1])
	{
		strcpy(mp, p);
	}
	Name(const Name &r)
	{
		deepCopy(r);
	}
	Name &operator=(const Name &r)
	{
		if (this == &r)  //demek ki nesne kendine ataniyor
			return *this;

		releaseResources();
		return deepCopy(r);
	}


	~Name()
	{
		releaseResources();
	}

	void print()const
	{
		std::cout << "(" << mp << ")" << std::endl;
	}
	int getLength()const
	{
		return mlen;
	}
	void set(int idx, int c)
	{
		mp[idx] = c;
	}
};


void gfunc(Name p)
{
	std::cout << "gfunc cagrildi \n";
	p.print();
}


//client.cpp
int main()
{
	Name name1 = "mustafa aksoy";
	
	name1 = name1;

	name1.print();

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;


class Myclass {
	//
public:
	//
};


int main()
{
	Myclass m1, m2, m3, m4;

	m1 = m2;
	m1.operator=(m2);

	m1 = m2 = m3 = m4;

	m1.operator=(m2.operator=(m3.operator=(m4)));

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

Dikkat! Bir sınıf için kopyalayan kurucu işlevinin kodunu siz yazıyorsanız
hayata gelecek nesnenin tüm öğelerinin hayata getirilmesinden siz sorumlusunuz.
Bir ya da birden fazla öğeye ilk değer vermezseniz
primitive ogeler cop degerle (garbage value - indetermined value) hayata gelir
sınıf türlerinden öğeler default ctor ile hayata getirilir.


Dikkat! Bir sınıf için atama işlevinin kodunu siz yazıyorsanız
kendisine atama yapılacak nesnenin tüm öğelerinin diğer nesnenin öğelerinden değerini almasından siz sorumlusunuz.
Bir ya da birden fazla öğeye atama yapmazsanız
bu öğeler atanmamış şekilde eski değerlerini korurlar.



class Car {
public:
	/////
};

class Mercedes : public Car{
	//////
};


int main()
{
	Mercedes m;
	Car *ptr = &m; //upcasting
	Car &r = m;  //upcasting
	Car mycar = m;  //gecerli ama hemen her zaman yanlış (nesne dilimlenmesi) (object slicing)

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base()
	{
		std::cout << "Base::Base()" << std::endl;
	}

	Base(const Base &r)
	{
		std::cout << "Base::Base(const Base &r)" << std::endl;
	}

};


class Der : public Base {


};


int main()
{
	Der d1;
	Der d2(d1);

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base()
	{
		std::cout << "Base::Base()" << std::endl;
	}

	Base(const Base &r)
	{
		std::cout << "Base::Base(const Base &r)" << std::endl;
	}

};


class Der : public Base {

public:
	Der() {

	}
	Der(const Der &r)  //muhtemelen yanlis
	{
		
	}
};


int main()
{
	Der d1;
	Der d2(d1);

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base()
	{
		std::cout << "Base::Base()" << std::endl;
	}

	Base(const Base &r)
	{
		std::cout << "Base::Base(const Base &r)" << std::endl;
	}

};


class Der : public Base {

public:
	Der() {

	}
	Der(const Der &r) : Base(r)
	{
		
	}
};


int main()
{
	Der d1;
	Der d2(d1);

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base &operator=(const Base &r)
	{
		std::cout << "Base operator =()" << std::endl;
		return *this;
	}
};


class Der : public Base {

public:
};


int main()
{
	Der d1, d2;

	d1 = d2;

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base &operator=(const Base &r)
	{
		std::cout << "Base operator =()" << std::endl;
		return *this;
	}
};


class Der : public Base {

public:
	Der &operator=(const Der &r)
	{
		std::cout << "Der operator =()" << std::endl;
		return *this;
	}
};


int main()
{
	Der d1, d2;

	d1 = d2;

}
//--------------------------------------------------
//--------------------------------------------------

#include <iostream>

using namespace std;

class Base {

public:
	Base &operator=(const Base &r)
	{
		std::cout << "Base operator =()" << std::endl;
		return *this;
	}
};


class Der : public Base {

public:
	Der &operator=(const Der &r)
	{
		std::cout << "Der operator =()" << std::endl;
		Base::operator=(r);
		return *this;
	}
};


int main()
{
	Der d1, d2;

	d1 = d2;

}
//--------------------------------------------------
//--------------------------------------------------

to override  a function
polymorphic


class Airplane {
public:
	void takeoff();
	virtual void land();
	virtual void fly() = 0;
};

abstract class (nesne oluşturamayız)
concrete class  (nesne oluşturabiliriz)


class Airplane {
public:
	void takeoff();
	virtual void land();
	virtual void fly() = 0;
};

int main()
{
	Airplane ap;  //gecersiz, sanal sınıflar türünden nesneler oluşturulamaz

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

class Airplane {
public:
	void takeoff();
	virtual void land();
	virtual void fly() = 0;
};

class Boeing : public Airplane {

};

int main()
{
	Boeing b;  //gecersiz, sanal sınıflar türünden nesneler oluşturulamaz

	return 0;
}
//--------------------------------------------------
//--------------------------------------------------

Kalıtımda
Taban sınıfın sanal ya da saf sanal işleviyle 
aynı isimli 
aynı imzaya sahip
aynı geri dönüş değeri türüne sahip bir işlev bildirirsek bu işlevi "override" etmiş oluyoruz.

Kalıtımda
Taban sınıfın sanal ya da saf sanal işleviyle 
aynı isimli 
aynı imzaya sahip
farklı geri dönüş değeri türüne sahip bir işlev bildirirsek bu sentaks hatası


Kalıtımda
Taban sınıfın sanal ya da saf sanal işleviyle 
aynı isimli 
farklı imzaya sahip
bir işlev bildirirsek bu gecerli ancak bu durum function overriding değil (overloading de değil)





class Base {
public:
	virtual void func(int, int);
};


class Der : public Base {
public:
	void func(int, int);  //override
};

//--------------------------------------------------
//--------------------------------------------------




class Base {
public:
	virtual void func(int, int);
};


class Der : public Base {
public:
	int func(int, int);  //gecersiz
};

//--------------------------------------------------
//--------------------------------------------------




class Base {
public:
	virtual void func(int, int);
};


class Der : public Base {
public:
	int func(int);  //gecerli
};

//--------------------------------------------------
//--------------------------------------------------

/*--------------------------------------------------------------------------------------------------------
	friend bir sınıf arkadaş olduğu sınıfın private elemanlarına erişebilir
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	 friend class Mample;
private:
	void Foo()
	{
		//...
	}
	int m_x;
};

class Mample {
public:
	void Bar()
	{
		Sample s;

		s.m_x = 23;
		s.Foo();
	}
};

int main()
{
	Mample m;

	m.Bar();	

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Global friend fonksiyonlar arkadaş oldukları sınıfın private elemanlarına erişebilirler
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	friend void Bar(const Sample &r);
public:
	Sample(int x) : m_x(x)
	{}
private:
	void Foo() const
	{
		cout << "Sample::Foo" << endl;
	}
	int m_x;
};


void Bar(const Sample &r)
{
	cout << r.m_x << endl;
	r.Foo();
}


int main()
{
	Sample s(10);

	Bar(s);
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir sınıfın üye fonksiyonu başka bir sınıfa arkadaş olabilir
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample;

class Mample {
	//...
public:
	void Bar(const Sample *r);
};

class Sample {
	friend void Mample::Bar(const Sample *r);
public:
	Sample(int x) : m_x(x)
	{}
private:
	void Foo() const
	{
		cout << "Sample::Foo" << endl;
	}
	int m_x;
};

void Mample::Bar(const Sample *r)
{
	cout << r->m_x << endl;
	r->Foo();
}

int main()
{
	Sample s(30);

	Mample m;

	m.Bar(&s);
	
	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	operator << ve operator >> operatör fonksiyonları
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
	friend istream &operator >>(istream &is, Number &r);
public:
	Number(int val = 0) : m_val(val)
	{}
	int GetVal() const { return m_val; }
	void SetVal(int val)
	{
		m_val = val;
	}
private:
	int m_val;
};

ostream &operator << (ostream &os, const Number &r) 
{
	return os << r.GetVal();
}

istream &operator >>(istream &is, Number &r)
{
	return is >> r.m_val;
}

int main()
{
	Number n(10);

	cout << n << "\n";
	cout << "Bir sayı giriniz\n";
	cin >> n;

	cout << n << "\n";
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Fonksiyon çağırma operatör fonksiyonları
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void operator()()
	{
		cout << "operator()()" << endl;
	}

	int operator()(int val)
	{
		cout << "operator()(int)" << endl;

		return val * val;
	}
};

int main()
{
	Sample s;

	s();
	cout << s(4) << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Fonksiyon çağırma operatör fonksiyonları
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
	friend istream &operator >>(istream &is, Number &r);
	friend ostream &operator << (ostream &os, const Number &r);	
public:
	Number(int val = 0) : m_val(val)
	{}
	int GetVal() const { return m_val; }
	void SetVal(int val)
	{
		m_val = val;
	}
	Number operator()(int val) const;
	void operator()() const;
private:
	int m_val;
};


void Number::operator()() const
{
	cout << *this << endl;
}

Number Number::operator()(int val) const
{
	return Number(m_val + val);
}

ostream &operator << (ostream &os, const Number &r)
{
	return os << r.GetVal();
}

istream &operator >>(istream &is, Number &r)
{
	return is >> r.m_val;
}

int main()
{
	Number n(10);

	cout << n(20) << endl;

	n();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Tür dönüştürme operatör fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Number {
	friend istream &operator >>(istream &is, Number &r);
	friend ostream &operator << (ostream &os, const Number &r);
public:
	Number(int val = 0) : m_val(val)
	{}
	int GetVal() const { return m_val; }
	void SetVal(int val)
	{
		m_val = val;
	}
	Number operator()(int val) const;
	void operator()() const;
	explicit operator int() const ;
private:
	int m_val;
};


void Number::operator()() const
{
	cout << *this << endl;
}

Number Number::operator()(int val) const
{
	return Number(m_val + val);
}

Number::operator int() const
{
	return m_val;
}

ostream &operator << (ostream &os, const Number &r)
{
	return os << r.GetVal();
}

istream &operator >>(istream &is, Number &r)
{
	return is >> r.m_val;
}

int main()
{
	Number n(10);

	int val = (int)n;

	cout << val << endl;	
		
	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	Complex sınıfı
---------------------------------------------------------------------------------------------------------*/


// main.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

int main()
{
	Complex x(3, 2), y;

	y = x + 10;

	y.disp();

	return 0;
}

// main.cpp
#include <iostream>

#include "Complex.hpp"

using namespace std;

int main()
{
	Complex z;
	cout << "Karmaşık sayıyı giriniz\n";
	cin >> z;

	cout << z << endl;
	
	return 0;
}

//main.cpp

#include <iostream>

#include "Complex.hpp"

using namespace std;

int main()
{
	Complex z(3, 4);

	cout << 3.4 + z << endl;
	cout << 3.4 * z << endl;
	cout << 3.4 - z << endl;
	
	return 0;
}

//main.cpp
#include <iostream>
#include "Complex.hpp"

using namespace std;

int main()
{
	Complex z(3, 4);

	z();

		
	return 0;
}

//main.cpp
#include <iostream>
#include "Complex.hpp"

using namespace std;

int main()
{
	Complex z(3, 4);

	cout << (double)z << endl;	
		
	return 0;
}

#ifndef COMPLEX_HPP_
#define COMPLEX_HPP_

#include <iostream>
#include <cmath>

class Complex {
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
	friend std::istream &operator >>(std::istream &is, Complex &r);
	friend Complex operator +(double x, const Complex &r);
	friend Complex operator *(double x, const Complex &r);
	friend Complex operator -(double x, const Complex &r);
public:
	Complex();
	Complex(double real, double imag = 0);
public:
	double &Real() { return  m_real; }
	const double &Real() const { return  m_real; }
	double &Imag() { return  m_imag; }
	const double &Imag() const { return  m_imag; }
	double Norm() const;
public:
	void disp() const;
public:	
	Complex operator +(const Complex &x) const;
	Complex operator +(double x) const;
	Complex operator -(const Complex &x) const;
	Complex operator *(const Complex &x) const;
	Complex operator -() const;
	Complex &operator ++();			// prefix
	const Complex operator ++(int);	// postfix
	void operator()() const;
	explicit operator double() const;
private:
	double m_real, m_imag;
};

#endif

#include <iostream>
#include <cmath>
#include "Complex.hpp"

using namespace std;

ostream &operator<<(ostream &os, const Complex &r)
{
	os << r.m_real;
	if (r.m_imag != 0) {
		os << (r.m_imag < 0 ? "-" : "+");
		if (fabs(r.m_imag) != 1)
			os << fabs(r.m_imag);
		os << "i";
	}

	return os;
}

istream &operator >>(istream &is, Complex &r)
{
	return is >> r.m_real >> r.m_imag;
}

Complex operator +(double x, const Complex &r)
{
	return r + x;
}

Complex operator *(double x, const Complex &r)
{
	return r * x;
}

Complex operator -(double x, const Complex &r)
{
	return x + -r;
	//return -1 * (r - x);
}

Complex::Complex() 
{
	m_real = m_imag = 0;
}

Complex::Complex(double real, double imag)
{
	m_real = real;
	m_imag = imag;
}

inline double Complex::Norm() const 
{
	return sqrt(m_real * m_real + m_imag * m_imag);
}

void Complex::disp() const
{
	cout << m_real;
	if (m_imag != 0) {
		cout << (m_imag < 0 ? "-" : "+");
		if (fabs(m_imag) != 1)
			cout << fabs(m_imag);
		cout << "i";
	}
	cout << endl;
}

Complex Complex::operator +(const Complex &x) const
{
	Complex result;

	result.m_real = m_real + x.m_real;
	result.m_imag = m_imag + x.m_imag;
	
	return result;
}

Complex Complex::operator +(double x) const
{
	Complex result;

	result.m_real = m_real + x;
	result.m_imag = m_imag;

	return result;
}

Complex Complex::operator -(const Complex &x) const
{
	Complex result;

	result.m_real = m_real - x.m_real;
	result.m_imag = m_imag - x.m_imag;

	return result;
}

Complex Complex::operator *(const Complex &x) const
{
	Complex result;

	result.m_real = m_real * x.m_real - m_imag * x.m_imag;
	result.m_imag = m_real * x.m_imag + m_imag * x.m_real;

	return result;
}

Complex Complex::operator -() const
{
	Complex result;

	result.m_real = -m_real;
	result.m_imag = -m_imag;

	return result;
}

Complex &Complex::operator ++()
{
	++m_real;

	return *this;
}

const Complex Complex::operator ++(int)
{
	Complex result = *this;

	++m_real;

	return result;
}

void Complex::operator()() const
{
	cout << *this << endl;
}

Complex::operator double() const
{
	return Norm();
}

/*--------------------------------------------------------------------------------------------------------
	static_cast tür dönüştürme operatörü
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

int main()
{
	srand(static_cast<unsigned int>(time(0)));

	for (int i = 0; i < 10; ++i)
		cout << rand() % 100 << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	const_cast tür dönüştürme operatörü const bir adresi aynı türden const olmayan adrese dönüştürür
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
	int a = 45;
	const int *pc = &a;
	int *p;
	
	p = const_cast<int *>(pc);

	*p = 20;

	cout << a << endl;
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	reinterpret_cast operatörü farklı türden adresleri dönüştürmek için kullanılır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstdint>

using namespace std;

int IsLittleEndian()
{
	int16_t x = 1;

	return *reinterpret_cast<char *>(&x) == 1;
}

int main()
{
	cout << (IsLittleEndian() ? "Little endian" : "Big Endian") << endl;		
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte const bir adres farklı türden const olmayan bir adrese dönüştürülmüştür.
	Aşağıdaki gibi iki şekilde yapılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	const int *pc = &a;
	long *p1 = reinterpret_cast<long *>(const_cast<int *>(pc));
	long *p2 = const_cast<long *>(reinterpret_cast<const long *>(pc));

	//...
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	qsort fonksiyonu ile void * göstericiler sayesinde türden bağımsız işlem yapmak mümkündür.
	Ancak yine de kod karmaşık gözükebilmektedir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstdlib>

using namespace std;

int CompInt(const void *pv1, const void *pv2)
{
	int *p1 = (int *)pv1;
	int *p2 = (int *)pv2;

	return *p1 - *p2;
}

int main()
{
	int a[] = {-4, 9, -6, 7, -9, 2, -3};

	qsort(a, 7, sizeof(int), CompInt);

	for (int i = 0; i < 7; ++i)
		cout << a[i] << " ";


	cout << "\n";

	
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	template fonksiyon tanımlaması
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <cstdlib>

using namespace std;

template <class T>
void Foo(T t)
{
	//...	
}

template <typename T1, typename T2>
T2 Add(T1 t1, T2 t2)
{
	//...
}


int main()
{
	
	
	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Template fonskiyonlar açım yaparak çağrılabilir. Bu durumda derleyici her açım için bir yeni bir 
	fonksiyon yazar. Şüphesiz daha önceden açım yapılan tür için yeni bir çağrıda yeni fonksiyon 
	yazmaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <class T>
void Foo(T t)
{
	cout << t << endl;
}

int main()
{
	Foo<int>(10);
	Foo<const char *>("ANKARA");
	Foo<string>("izmir");
	Foo<int>(20);	
	
	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Template parametrelerin hepsi fonksiyon parametresi olarak kullanılmışsa bu durumda açım
	yapmaya gerek olmaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
void Foo(T t)
{
	cout << t << endl;
}

int main()
{
	Foo(10);
	Foo("ANKARA");
	Foo(string("izmir"));
	Foo(20);	
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Template parametrelerin hepsi fonksiyon parametresi olarak kullanılmışsa bu durumda açım
	yapmaya gerek olmaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename K>
void Foo(T t, K k)
{
	cout << t << endl;
	cout << k << endl;
}

int main()
{
	Foo<int, string>(10, "ankara");
	Foo(10, 3.4);
	
	return 0;
}

/*--/*--------------------------------------------------------------------------------------------------------
	Template parametreler için çağrı yapıldığında açılımlar için bir kısmı verilip bir kısmı
	tür tespitine bırakılabilir. Ancak açılacak türün soldan başlayarak verilmesi gerekir. Yani 
	sadece aradaki bir türün açılması mümkün değildir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T1, typename T2, typename T3>
T3 Add(T1 t1, T2 t2)
{
	return t1 + t2;
}

int main()
{
	cout << Add<int, int, int>(10, 20) << endl;
	cout << Add<int, double, double>(10, 2.3) << endl;

	return 0;
}

------------------------------------------------------------------------------------------------------
	Template parametreler için çağrı yapıldığında açılımlar için bir kısmı verilip bir kısmı
	tür tespitine bırakılabilir. Ancak açılacak türün soldan başlayarak verilmesi gerekir. Yani 
	sadece aradaki bir türün açılması mümkün değildir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T1, typename T2, typename T3>
void Foo(T1 t1, T2 t2, T3 t3)
{
	cout << t1 << endl;
	cout << t2 << endl;
	cout << t3 << endl;
}

int main()
{
	Foo<int>(10.4, "ankara", true);
	Foo<double, string>(10.4, "ankara", 45);
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Template parametreler için çağrı yapıldığında açılımlar için bir kısmı verilip bir kısmı
	tür tespitine bırakılabilir. Ancak açılacak türün soldan başlayarak verilmesi gerekir. Yani 
	sadece aradaki bir türün açılması mümkün değildir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T1, typename T2, typename T3>
T1 Add(T2 a, T3 b)
{
	return a + b;
}

int main()
{
	cout << Add<int>(10, 20) << endl;
	cout << Add<double>(10, 2.3) << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Template fonksiyonlar tür için derleyici tarafından yazılırken sentaks ve semantik kontrol yapılır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
void Foo(const T &t)
{
	cout << t << endl;
}

class Sample {
public:
	

};

int main()
{
	Foo(10);
	Sample s;

	Foo(s); //error

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	template parametreler fonksiyon göstericisi olarak da açılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename F>
void ForEach(const T *p, size_t size, F fn)
{
	for (size_t i = 0; i < size; ++i)
		fn(p[i]);
}

template <typename T>
void Display(const T &r)
{
	cout << r << endl;
}

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6 };

	ForEach(a, 6, Display<int>);

	string names[] = {"ankara", "istanbul","izmir"};

	ForEach(names, 3, Display<string>);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Şablon bir Swap fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
void Swap(T &r1, T &r2)
{
	T temp = r1;

	r1 = r2;
	r2 = temp;
}

int main()
{
	int a = 10, b = 20;
	string s1("ankara"), s2("istanbul");

	Swap(a, b);
	Swap(s1, s2);

	cout << "a=" << a << endl;
	cout << "b=" << b << endl;
	cout << "s1=" << s1 << endl;
	cout << "s2=" << s2 << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Şablon fonksiyonlar ile aynı isimde fonksiyon yazılabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
void Foo(const T &r)
{
	cout << "Foo(T)" << endl;
	cout << r << endl;
}

void Foo(int val)
{
	cout << "Foo(int)" << endl;
	cout << val << endl;
}

int main()
{
	Foo(10);
	Foo(10.3);
	Foo<int>(23);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Şablon fonksiyonlar
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include "Complex.hpp"
#include "Rational.hpp"

using namespace std;

template <typename T>
T Add(const T &t1, const T &t2)
{
	return t1 + t2;
}

int main()
{
	cout << Add(string("ankara"), string("istanbul")) << endl;	

	Complex z1(3, 4), z2(5, -7);

	cout << Add(z1, z2) << endl;
	
	Rational r1(2, 3), r2(5, -6);

	cout << Add(r1, r2) << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Şablon fonksiyonlar
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
T Max(const T *p, size_t size)
{
	T max = *p;

	for (size_t i = 1; i < size; ++i)
		if (max < p[i])
			max = p[i];

	return max;
}

int main()
{
	int a[] = {1, -5, 6, 7};
	string str[] = { "zonguldak", "bolu", "adana", "ankara"};

	string city = Max(str, 4);
	int max = Max(a, 4);

	cout << city << endl;
	cout << max << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Şablon fonksiyonlar
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include "Complex.hpp"

using namespace std;

template <typename T>
T Sum(const T *p, size_t size)
{
	T sum = T();

	for (size_t i = 0; i < size; ++i)
		sum = sum + p[i]; //operator +: Dikkat += kullanılsaydı operator += fonskiyonu da yazılması gerekirdi
	   
	return sum;
}

int main()
{
	int a[] = {1, -5, 6, 7};
	string str[] = { "zonguldak", "bolu", "adana", "ankara"};
	Complex c[] = {Complex(3, 4), Complex(3, -9) };

	string s = Sum(str, 4);
	int sum = Sum(a, 4);
	Complex z = Sum(c, 2);

	cout << s << endl;
	cout << sum << endl;
	cout << z << endl;

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	sort fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
void Display(const T *p, size_t size)
{
	for (int i = 0; i < size; ++i)
		cout << p[i] << " ";

	cout << "\n";
}

int main()
{
	int a[] = {1, -5, 6, 7};
	string str[] = { "zonguldak", "bolu", "adana", "ankara"};

	sort(a, a + 4);
	sort(str, str + 4);

	Display(a, 4);
	Display(str, 4);	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	sort fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
void Display(const T *p, size_t size)
{
	for (int i = 0; i < size; ++i)
		cout << p[i] << " ";

	cout << "\n";
}

bool CompInt(int a, int b)
{
	return b <= a;
}

bool CompStr(const string &s1, const string &s2)
{
	return s2 <= s1;
}

int main()
{
	int a[] = {1, -5, 6, 7};
	string str[] = { "zonguldak", "bolu", "adana", "ankara"};

	sort(a, a + 4, CompInt);
	sort(str, str + 4, CompStr);

	Display(a, 4);
	Display(str, 4);	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	fill fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
void Display(const T *p, size_t size)
{
	for (int i = 0; i < size; ++i)
		cout << p[i] << " ";

	cout << "\n";
}

int main()
{
	int a[10];
	string str[10];

	fill(a, a + 10, -1);
	fill(str, str + 10, string());	

	Display(a, 4);
	Display(str, 4);	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	reverse fonksiyonu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
void Display(const T *p, size_t size)
{
	for (int i = 0; i < size; ++i)
		cout << p[i] << " ";

	cout << "\n";
}

int main()
{
	int a[] = { 1, -5, 6, 7 };
	string str[] = { "zonguldak", "bolu", "adana", "ankara" };

	reverse(a, a + 4);
	reverse(str, str + 4);

	Display(a, 4);
	Display(str, 4);	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	template sınıf bildirimi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(const T &t) : m_t(t)
	{}
public: 
	void Display()
	{
		cout << m_t << endl;
	}
private:
	T m_t;	
};


int main()
{
	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	template sınıflar sınıf dışında açım yapılmadan kullanılamaz
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(const T &t) : m_t(t)
	{}
public: 
	void Display() const
	{
		cout << m_t << endl;
	}
private:
	T m_t;	
};


int main()
{
	Sample<int> s(10);

	s.Display();

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	template sınıfların üye fonksiyonları sınıf dışında bildirilirken de template kullanılmalıdır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(const T &t);
public: 
	void Display() const;
private:
	T m_t;	
};

template <typename T>
Sample<T>::Sample(const T &t) : m_t(t)
{}

template <typename T>
void Sample<T>::Display() const
{
	cout << m_t << endl;
}

int main()
{
	Sample<int> s(10);

	s.Display();

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	template sınıfların özelleştirilmesi
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(const T &t);
public: 
	void Display() const;
private:
	T m_t;	
};

template <typename T>
Sample<T>::Sample(const T &t) : m_t(t)
{}

template <typename T>
void Sample<T>::Display() const
{
	cout << "Sample<T>" << endl;
	cout << m_t << endl;
}

template <>
class Sample<int> {
public:
	Sample(const int &val) : m_val(val)
	{}
public:
	void Display() const
	{
		cout << "Sample<int>" << endl;
		cout << m_val << endl;
	}
private:
	int m_val;
};

int main()
{
	Sample<double> sd(3.4);

	sd.Display();

	Sample<int> si(10);

	si.Display();

	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	Sınır kontrolü yapan basit bir Array sınıfı ve test kodları
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include "Array.hpp"

using namespace std;


int main()
{
	Array<int> a(20);

	for (int i = 0; i < 20; ++i)
		a[i] = i * 10;

	for (size_t i = 0; i < a.GetSize(); ++i)
		cout << a[i] << " ";

	cout << endl;

	return 0;
}

//main.cpp

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include "Array.hpp"

using namespace std;

void Display(Array<int> a)
{
	for (size_t i = 0; i < a.GetSize(); ++i)
		cout << a[i] << " ";

	cout << endl;
}

int main()
{
	Array<int> a;

	srand(static_cast<unsigned int>(time(0)));

	for (int i = 0; i < a.GetSize(); ++i)
		a[i] = rand() % 101;

	Display(a);
	Display(a);

	return 0;
}

//main.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include "Array.hpp"

using namespace std;

void Display(Array<int> a) //Kötü teknik
{
	for (size_t i = 0; i < a.GetSize(); ++i)
		cout << a[i] << " ";

	cout << endl;
}

int main()
{
	Array<int> a;

	srand(static_cast<unsigned int>(time(0)));

	for (int i = 0; i < a.GetSize(); ++i)
		a[i] = rand() % 101;

	Display(a);

	a = a; //self assignment

	{
		Array<int> b;

		b = a; //operator =
	}

	Display(a);

	return 0;
}

//Array.hpp
#ifndef ARRAY_HPP_
#define ARRAY_HPP_

#include <iostream>
#include <cstdlib>
#include <cstring>

template <typename T>
class Array {
public:
	Array(size_t size = 10) : m_p(new T[size]), m_size(size)
	{}
	Array(const Array &r);
	Array &operator =(const Array &r);
	//...
	~Array() 
	{
		delete[] m_p;
	}
	size_t GetSize() const { return m_size; }
	T &operator [](size_t index);
	const T &operator [](size_t index) const;
private:
	static void controlBounds(const char * str);
private:
	T *m_p;
	size_t m_size;	
};

template <typename T>
void Array<T>::controlBounds(const char *str)
{
	std::cerr << str << std::endl;
	exit(EXIT_FAILURE); //Exception konusuna kadar sabır
}

template <typename T>
Array<T>::Array(const Array &r) : m_p(new T[r.m_size]), m_size(r.m_size)
{
	std::memcpy(m_p, r.m_p, sizeof(T) * m_size);
}

template <typename T>
Array<T> &Array<T>::operator =(const Array &r)
{
	if (this == &r) //self assignement
		return *this;

	delete[] m_p;
	m_size = r.m_size;
	m_p = new T[m_size];
	memcpy(m_p, r.m_p, sizeof(T) * m_size);

	return *this;
}

template <typename T>
T &Array<T>::operator [](size_t index)
{
	if (index >= m_size)
		controlBounds("out of range");
		
	return m_p[index];
}

template <typename T>
const T &Array<T>::operator [](size_t index) const
{
	if (index >= m_size)
		controlBounds("const out of range");

	return m_p[index];
}

#endif // ARRAY_HPP_

/*--------------------------------------------------------------------------------------------------------
	Şablon parametreler bir türe ilişkin olabilir. Bu durumda bu parametre açılımda sabit ifadesi
	olarak geçilmelidir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>


using namespace std;

template <typename T, size_t N>
class Sample {
	//...
public:
	T a[N];
};

int main()
{
	int n = 10;

	Sample<int, 10> s;
	


	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	default template parametreleri
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;


template <typename T, size_t N = 10>
class Sample {
	//...
public:
	T a[N];
};

int main()
{
	int n = 10;

	Sample<string> s;
	


	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	Karmaşık template açılımlarında typedef kullanımı teması
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>
#include "Array.hpp"

using namespace std;


template <typename T, size_t N = 10>
class Sample {
	//...
public:
	T a[N];
};

typedef Sample<Array<string>> SArray;

int main()
{
	int n = 10;

	SArray s;	


	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları da template olabilir (member template). Bu durumda sınıf dışında
	iki tane template ile tanımlanmalıdır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
class Sample {
public:
	template <typename K>
	void Foo(T t, K k);
private:
	T m_t;
};

template <typename T>
template <typename K>
void Sample<T>::Foo(T t, K k)
{
	//...
}

int main()
{
	Sample<int> s;

	s.Foo(10, "ankara");

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları da template olabilir (member template). Bu durumda sınıf dışında
	iki tane template ile tanımlanmalıdır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
class Sample {
public:
	template <typename K>
	static void Foo(T t);
private:
	T m_t;
};

template <typename T>
template <typename K>
void Sample<T>::Foo(T t)
{
	//...
}

int main()
{
	Sample<int>::Foo<string>(10);

	return 0;
}

//Array.hpp
#ifndef ARRAY_HPP_
#define ARRAY_HPP_

#include <iostream>
#include <cstdlib>
#include <cstring>

template <typename T, size_t SIZE = 10>
class Array {
public:	
	size_t GetSize() const { return SIZE; }
	T &operator [](size_t index);
	const T &operator [](size_t index) const;
private:
	static void controlBounds(const char * str);
private:
	T m_p[SIZE];	
};

template <typename T, size_t SIZE>
void Array<T, SIZE>::controlBounds(const char *str)
{
	std::cerr << str << std::endl;
	exit(EXIT_FAILURE); //Exception konusuna kadar sabır
}


template <typename T, size_t SIZE>
T &Array<T, SIZE>::operator [](size_t index)
{
	if (index >= SIZE)
		controlBounds("out of range");
		
	return m_p[index];
}

template <typename T, size_t SIZE>
const T &Array<T, SIZE>::operator [](size_t index) const
{
	if (index >= SIZE)
		controlBounds("const out of range");

	return m_p[index];
}

#endif // ARRAY_HPP_

/*--------------------------------------------------------------------------------------------------------
	template bir fonksiyon bir sınıfa friend olabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

class Sample {
	template <typename T>
	friend void Foo(T t, const Sample &r);
};


template <typename T>
void Foo(T t, const Sample &r)
{
	//...
}



int main()
{
	Sample s;

	Foo(10, s);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	template bir fonksiyon bir template sınıfa friend olabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template <typename T>
class Sample {
	template <typename K>
	friend void Foo(K k, const Sample<T> &r);
};

template <typename T, typename K>
void Foo(K k, const Sample<T> &r)
{
	//...
}



int main()
{
	Sample<int> s;

	Foo(10, s);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir sınıf template bir sınıfın herhangi bir açılımından türetilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class A {
	//...
};

class B : public A<int> {

};

int main()
{
	B b;   
	

	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	template bir sınıf template bir sınıfın herhangi bir açılımından türetilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class A {
	//...
};

template <typename T>
class B : public A<int> {

};

int main()
{
	B<bool> b;   
	B<int> b1;
	

	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	template bir sınıf template bir sınıftan türetilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class A {
	//...
};

template <typename T>
class B : public A<T> {

};

int main()
{
	B<bool> b;   
	B<int> b1;
	

	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	template bir sınıf template bir sınıftan türetilebilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class A {
	//...
};

template <typename T, typename K>
class B : public A<K> {

};

int main()
{
	B<bool, int> b;   
	B<int, double> b1;
	

	return 0;
}





/*--------------------------------------------------------------------------------------------------------
	vector sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main()
{
	vector<string> svec;
	string s;
	cout << "Yazıları girmeye başlayınız";

	for (;;) {
		cin >> s;
		if (s == "exit")
			break;

		svec.push_back(s);
	}

	for (int i = 0; i < svec.size(); ++i)
		cout << svec[i] << " ";

	cout << endl;

	return 0;
}



/*--------------------------------------------------------------------------------------------------------
	downcasting işlemi explicit yapılmalıdır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	int x;
};

class B : public A {
public:
	int y;
};



int main()
{
	B b;

	b.x = 30;
	b.y = 20;
	A &a = b;

	cout << a.x << endl;

	B &br = static_cast<B &>(a);

	cout << br.y << endl;

		
	return 0;
}
/*--------------------------------------------------------------------------------------------------------
	1) Biyolojik Tanım: Çok biçimlilik taban sınıfın belli bir fonksiyonunun 
	türemiş sınıflar tarafından temel işlevi aynı kalmak üzere onlara özgü 
	bir biçimde tanımlanmasıdır.

	2) Yazılım Mühendisliği Tanımı: Çokbiçimlilik türden bağımsız kod parçalarının
	yazılabilmesi için kullanılan bir tekniktir.

	3) Aşağı Seviyeli Tanım: Çokbiçimlilik önceden yazılmış kodların sonradan 
	yazılacak kodları çağırabilmesi özelliğidir. 
---------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------
	Çok biçimlilik sanal fonksiyonlar ile yapılır. Bir fonskiyon referans veya gösterici
	ile çağrıldığında o an referansın gösterdiği gerçek nesnenin türü ne ise ona ilişkin
	override edilmiş fonksiyon varsa çağrılır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo() // Sanal fonksiyon
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	virtual void Foo()
	{
		cout << "B::Foo\n";
	}
};

int main()
{	
	B b;

	b.Foo();

	A &a = b;

	a.Foo();
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir dizi türetme durumu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo()
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	virtual void Foo()
	{
		cout << "B::Foo\n";
	}
};

class C : public B {
public:
	virtual void Foo()
	{
		cout << "C::Foo\n";
	}
};

int main()
{	
	C c;

	A &a = c;

	a.Foo();
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir dizi türetme durumu
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo()
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	virtual void Foo()
	{
		cout << "B::Foo\n";
	}
};

class C : public B {

};

int main()
{	
	C c;

	A &a = c;

	a.Foo();
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aşağıdaki durumda B sınıfında Foo fonksiyonu override edilmemiştir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo(int a)
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	virtual void Foo(double a)
	{
		cout << "B::Foo\n";
	}
};



int main()
{	
	B b;

	A *p = &b;

	p->Foo(2.3);	
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	override anahtar sözcüğü ile bir fonksiyonun taban sınıftan override edilip edilmediği
	derleme zamanında da kontrol edilir. override anahtar sözcüğü okunabilirliği de artırır
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo(int a)
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	void Foo(int a) override
	{
		cout << "B::Foo\n";		
	}
};



int main()
{	
	B b;

	A *p = &b;

	p->Foo(2.3);	
		
	return 0;
}


/*--------------------------------------------------------------------------------------------------------
	Bir sınıf bir fonksiyonu override etmek zorunda değildir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo(int a)
	{
		cout << "A::Foo\n";
	}
};

class B : public A {
public:
	
};

class C : public B {
public:
	void Foo(int a) override
	{
		cout << "C::Foo\n";
	}
};


int main()
{	
	C c;

	A *p = &c;

	p->Foo(2.3);	
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir sınıf türetmeye kapatılmıştır. Her istendiğinde dinamik olarak bir adres
	döndüren bir fonksiyon yazılmıştır. Bu tasarım farklı şekilde yapılabilir. Bu tasarımda 
	nesneyi delete etmek GetInstance çağıranın sorumluluğudadır.
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	static A *GetInstance()
	{
		return new A;
	}
private:
	A() {}
};


int main()
{	
	A *p = A::GetInstance();


	delete p;
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	final anahtar sözcüğü ile bir sınıf türetmeye kapatılabilir. Bu durumda extra yapılacak
	bir iş yoktur. Yani constructor ın dışarıdan çağrılamamasını sağlayan bir kod yazılmayabilir
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A final {
	//...
};

class B : public A {}; //error

int main()
{	
	A a;

	B b;


	
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bir fonksiyon override ve final olarak bildirilirse o fonksiyonun ait olduğu sınıftan
	türetme yapıldığında artık override edilemez
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public: 
	virtual void Foo(int val)
	{
		cout << "A::Foo" << endl;
	}
};

class B : public A {
public:
	void Foo(int val) override final
	{
		cout << "A::Foo" << endl;
	}
};

class C : public B {
public:
	void Foo(int val) override //error
	{
		cout << "A::Foo" << endl;
	}
};

int main()
{	
	A a;

	B b;
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	override edilen fonksiyonlar içerisinde taban sınıfın fonksiyonunu çağrılmasına
	çok sık rastlanır. Bu durumda programcı aslında hem kendi işini hem de taban sınıfın
	yaptığı işi de içeren bir fonksiyon yazmış olur
---------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
	virtual void Foo(int val)
	{
		cout << "A::Foo\n";
	}

};

class B : public A {
public:
	void Foo(int val) override
	{
		cout << "B::Foo\n";
		A::Foo(val);
	}
};

class C : public B {
public:
	void Foo(int val) override
	{
		cout << "C::Foo\n";
		B::Foo(val);
	}
};

int main()
{	
	C c;

	A &a = c;

	a.Foo(10);
	
		
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Bazı çokbiçimli uygulamalarda taaban sınıftaki sanal fonksiyonlar aslında hiç çağrılmazlar. Bunlar
	türden bağımsız çokbiçimli işlem yapmak için bulundurulmuştur. İşte sanal fonksiyon bildiriminde = 0
	sentaksı kullanılırsa bu tür sanal fonskiyonlara "saf sanal fonksiyonlar (pure virtual functions)" 
	denilmektedir. En az bir saf sanal fonksiyona sahip olan sınıfa da "soyut sınıf (abstract class)" denir. 
	Soyut sınıflar türünden nesneler yaratılamazlar. Ancak göstericiler ce referanslar tanımlanabilirler.
---------------------------------------------------------------------------------------------------------*/

class Shape {
public:
	virtual void move_down() = 0;
	virtual void move_left() = 0;
	virtual void move_right() = 0;
	virtual void rotate() = 0;
};

/*--------------------------------------------------------------------------------------------------------
	Bir soyut sınıftan türetilen sınıflar taban sınıfın saf sanal fonksiyonlarını override etmelidir. Aksi 
	takdirde türemiş sınıf da soyut olur. Türemiş sınıf türünden de nesneler yaratamayız.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>


using namespace std;

class A {
	virtual void foo() = 0;
};

class B : public A {
	//...
};

int main()
{	
	A a;		// error!
	B b;		// error!
			
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Saf sanal fonksiyonlar türemiş sınıfta override edilmezlerse türemiş sınıflar da soyut olur
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
	virtual void foo() = 0;
};

class B : public A {
public:
	void foo() override;
};

void B::foo()
{
	cout << "B::foo" << endl;
}

int main()
{	
	B b;		// geçerli

	b.foo();
			
	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Taban A isimli soyut sınıfın bir grup saf sanal fonksiyonu ondan türetilmiş olan B sınıfında override
	edilmiş olsun. Geri kalan saf sanal fonksiyonların da B'den türetilmiş olan C sınıfında override edildiğini
	varsayalım. Bu durumda B sınıfı soyuttur, fakat C sınıfı soyut değildir.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
	virtual void foo() = 0;
	virtual void bar() = 0;
};

class B : public A {
public:
	void foo() override;
};

void B::foo()
{
	cout << "B::foo" << endl;
}

class C : public B {
public:
	void bar() override;
};

void C::bar()
{
	cout << "C::bar" << endl;
}

int main()
{	
	C c;

	c.foo();
	c.bar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	try-catch bloklarının organizasyonu
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{	
	try {
		//...
	}
	catch (int) {
		//...
	}
	catch (long) {
		//...
	}
	catch (double) {
		//...
	}

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Programın akışı throw anahtar sözcüğünü gördüğünde akış bir goto gibi throw deyiminin ilişkin olduğu
	catch bloğuna aktarılır.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a);

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (int) {
		cout << "int catch block..." << endl;
	}
	catch (long) {
		cout << "long catch block..." << endl;
	}
	catch (double) {
		cout << "double catch block..." << endl;
	}
	cout << "main ends..." << endl;

	return 0;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw -1;

	cout << "foo ends..." << endl;
}

/*--------------------------------------------------------------------------------------------------------
	throw deyiminin yanındaki ifadenin değeri catcfh parametresine aktarılmaktadır
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a);

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (int a) {
		cout << "int catch block: " << a << endl;
	}
	catch (long a) {
		cout << "long catch block: " << a << endl;
	}
	catch (double a) {
		cout << "double catch block: " << a << endl;
	}
	cout << "main ends..." << endl;

	return 0;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw -20;

	cout << "foo ends..." << endl;
}

/*--------------------------------------------------------------------------------------------------------
	Eğer exception bir catch bloğu tarafından yakalanmazsa std::terminate fonksiyonu çağrılır. Bu fonksiyon
	da std::abort fonksiyonunu çağırır ve program sonlandırılır. 
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a);

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (int a) {
		cout << "int catch block: " << a << endl;
	}
	catch (long a) {
		cout << "long catch block: " << a << endl;
	}
	catch (double a) {
		cout << "double catch block: " << a << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw "this is test";

	cout << "foo ends..." << endl;
}

/*--------------------------------------------------------------------------------------------------------
	Fonksiyon başka bir fonksiyonu o da başka bir fonksiyonu çağırmış olabilir. Ne kadar dipte olursak olalım
	thwor işlemi ile geri dönmemecesine son girilen try bloğunun uygun catch bloğuna akış aktarılır
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a);
void bar(int a);
void tar(int a);

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (int a) {
		cout << "int catch block: " << a << endl;
	}
	catch (long a) {
		cout << "long catch block: " << a << endl;
	}
	catch (double a) {
		cout << "double catch block: " << a << endl;
	}
	catch (const char *str) {
		cout << "const char * catch block: " << str << endl;
	}
	cout << "main ends..." << endl;

	return 0;
}

void foo(int a)
{
	cout << "foo begins..." << endl;
	bar(a);
	cout << "foo ends..." << endl;
}

void bar(int a)
{
	cout << "bar begins..." << endl;
	tar(a);
	cout << "bar ends..." << endl;
}

void tar(int a)
{
	cout << "tar begins..." << endl;

	if (a < 0)
		throw "this is test";

	cout << "tar ends..." << endl;
}

/*--------------------------------------------------------------------------------------------------------
	Programcı yeni kendi exception sınıflarını yaratmak yerine mümkün olduğunda zaten var olan
	standart exception sınıflarını kullanabilir.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <stdexcept>

using namespace std;

void foo(int a);
void bar(int a);
void tar(int a);

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (const invalid_argument &ia) {
		cout << ia.what() << endl;
	}
		
	cout << "main ends..." << endl;

	return 0;
}

void foo(int a)
{
	cout << "foo begins..." << endl;
	bar(a);
	cout << "foo ends..." << endl;
}

void bar(int a)
{
	cout << "bar begins..." << endl;
	tar(a);
	cout << "bar ends..." << endl;
}

void tar(int a)
{
	cout << "tar begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must not be negative!");

	cout << "tar ends..." << endl;
}

/*--------------------------------------------------------------------------------------------------------
	Türemiş sınıf türünden bir throw işlemi taban sınıf türünden bir catch bloğu tarafından
	yakalanabilir
---------------------------------------------------------------------------------------------------------*/

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (const exception &ia) {
		cout << ia.what() << endl;
	}
			
	cout << "main ends..." << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Taban ve türemiş sınıflaraq ilişkin catch blokları beraber bulundurulabilir. Ancak bu durumda taban sınıfa
	ilişkin catch bloğunun türemiş sınıfa ilişkin catch bloğunun aşağısında bulundurulması gerekir. Çünkü
	catch bloklarına yukarıdan aşağıya doğru bakılmaktadır. 
---------------------------------------------------------------------------------------------------------*/

int main()
{	
	cout << "main begins..." << endl;
	try {
		foo(-10);
	}
	catch (const invalid_argument &e) {
		cout << e.what() << endl;
	}
	catch (const exception &e) {
		cout << e.what() << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Akış try bloğuna girdikten sonra eğer exception oluşursa henüz akış bir catch devredilmeden 
	daha önce yaratılmış olan yerel sınıf nesneleri için ters sırada tek tek destructor çağrılmaktadır.
	Bu işleme "stack unwinding" denilmektedir.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Sample {
public:
	Sample(int a)
	{
		cout << "constructor: " << a << endl;
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}
private:
	int m_a;
};

void foo(int a);
void bar(int a);
void tar(int a);

int main()
{	
	try {
		Sample x(10);

		foo(-10);
	}
	catch (const invalid_argument &e) {
		cout << e.what() << endl;
	}

	return 0;
}

void foo(int a)
{
	Sample y(20);

	bar(a);
}

void bar(int a)
{
	Sample z(30);

	tar(a);
}

void tar(int a)
{
	Sample k(40);

	if (a < 0)
		throw invalid_argument("value must not be negative!");
}

/*--------------------------------------------------------------------------------------------------------
	Stack unwinding işlemi dinamik nesneler için yapılmamaktadır. 
---------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Sample {
public:
	Sample(int a)
	{
		cout << "constructor: " << a << endl;
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}
private:
	int m_a;
};

void foo(int a);
void bar(int a);
void tar(int a);

int main()
{	
	try {
		Sample *x = new Sample(10);

		foo(-10);
	}
	catch (const invalid_argument &e) {
		cout << e.what() << endl;
	}

	return 0;
}

void foo(int a)
{
	Sample *y = new Sample(20);

	bar(a);
}

void bar(int a)
{
	Sample *z = new Sample(30);

	tar(a);
}

void tar(int a)
{
	Sample *k = new Sample(40);

	if (a < 0)
		throw invalid_argument("value must not be negative!");
}

/*--------------------------------------------------------------------------------------------------------
	Eğer programcı try bloğundan sonra 
	dinamik bir nesne yaratmışsa bunun boşaltımını kendisi ayarlamalıdır. Ya da bunun için unique_ptr, weak_ptr
	shared_ptr gibi sınıfları kullanmalıdır. Çünkü bu sınıflar adresleri bir sınıf nesnesinin içeriisnde tutar. 
	Stack unwinding işlemi sırasında sınıfın bitiş fonksiyonu (destructor) çağrılacağından bu sınıfların
	bitiş fonksiyonları da boşaltımı yapmaktadır.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Sample {
public:
	Sample(int a)
	{
		cout << "constructor: " << a << endl;
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}
private:
	int m_a;
};

void foo(int a);
void bar(int a);
void tar(int a);

int main()
{	
	try {
		unique_ptr<Sample> x(new Sample(10));

		foo(-10);
	}
	catch (const invalid_argument &e) {
		cout << e.what() << endl;
	}

	return 0;
}

void foo(int a)
{
	unique_ptr<Sample> y(new Sample(20));

	bar(a);
}

void bar(int a)
{
	unique_ptr<Sample> z(new Sample(30));

	tar(a);
}

void tar(int a)
{
	unique_ptr<Sample> k(new Sample(40));

	if (a < 0)
		throw invalid_argument("value must not be negative!");
}

/*--------------------------------------------------------------------------------------------------------
	C++'ta bir fonksiyonun hangi exception'larla throw edebildiği belirtilebilmektedir. Buna exception
	specification denilmektedir. Ancak exception specification içeren fonksiyonlar çağrılırken bunların
	try ile catch ile handle edilme zorunluluğu yoktur. (Halbuki Java'da böyle bir zorunluluk vardır.)
	Maalesef Microsoft C++ derleyicileri exception specification özelliğini tam olarak desteklememektedir. 
---------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

void foo(int a) throw(int);

int main()
{	
	try {

		foo(-10);
	}
	catch (int a) {
		cout << "exception(int) caught" << endl;
	}

	return 0;
}

void foo(int a) throw(invalid_argument)
{
	if (a < 0)
		throw invalid_argument("value must not be negative!.");
}

/*--------------------------------------------------------------------------------------------------------
	Çoklu türetme
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo();
};

void A::foo()
{
	cout << "A::foo" << endl;
}

class B {
public:
	void bar();
};

void B::bar()
{
	cout << "B::bar" << endl;
}

class C : public A, public B {
public:
	void tar();
};

void C::tar()
{
	cout << "C::tar" << endl;
}

int main()
{	
	C c;

	c.foo();
	c.bar();
	c.tar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Çoklu türetmede tüm taban sınıf kollarındaki fonksiyonlar ilk bulundukları sınıftan alınarak birlikte
	"overload resolution" işlemine sokulmaktadır. Yani farklı kollarda aynı parametrik yapıya sahip 
	fonksiyonlar varsa bunların çağrılması sırasında sorun oluşabilir.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo();
};

void A::foo()
{
	cout << "A::foo" << endl;
}

class B {
public:
	void foo();
};

void B::foo()
{
	cout << "B::bar" << endl;
}

class C : public A, public B {
public:
	void tar();
};

void C::tar()
{
	cout << "C::tar" << endl;
}

int main()
{	
	C c;

	c.foo();		// ambiguity error!
	c.tar();

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Çoklu türetmede sınıfların başlanıç fonksiyonları her zaman bildirimdeki sıraya bağlı olarak çalıştırılır.
	Yine hangi taban sınıfın hangi başlangıç metodunun çağrılacağı ctor (mil) sentaksıyla belirtilmektedir. 
	MIL sentaksındaki sıranın hiçbir önemi yoktur. Çağrım her zaman bildirimdeki sıraya göre yapılmaktadır.
	Eğer MIL sentaksında taban sınıf ismi belirtilmezse taban sınıfın default başlangıç fonksiyonu çağrılır.
	Sınıfın bitiş fonksiyonları her zaman yine ters sırada çağrılmaktadır.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A()
	{
		cout << "A constructor" << endl;
	}
	~A()
	{
		cout << "A destructor" << endl;
	}

};

class B {
public:
	B()
	{
		cout << "B constructor" << endl;
	}
	~B()
	{
		cout << "B destructor" << endl;
	}
};

class C : public A, public B {
public:
	C();
	~C()
	{
		cout << "C destructor" << endl;
	}
};

C::C() : B(), A()
{
	cout << "C constructor" << endl;
}

int main()
{	
	C c;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Çoklu türetmeden taban sınıflar da doğrudan ya da dolaylı biçimde başka bir sınıftan türetilmişlerse
	(elmas şekli türetme) bu durumda bu taban sınıflardan nesne içerisinde birden fazla kez bulunur. Bu da 
	pek çok sorun doğurma potansiytelindedir. 
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A()
	{
		cout << "A constructor" << endl;
	}
	~A()
	{
		cout << "A destructor" << endl;
	}

};

class B {
public:
	B()
	{
		cout << "B constructor" << endl;
	}
	~B()
	{
		cout << "B destructor" << endl;
	}
};

class C : public A, public B {
public:
	C();
	~C()
	{
		cout << "C destructor" << endl;
	}
};

C::C() : B(), A()
{
	cout << "C constructor" << endl;
}

int main()
{	
	C c;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Yukarıdaki sorundan kurtulmak için C++'ta sanal taban sınıf (virtual base class) kavramı geliştirilmiştir.
	Eğer taba listede taban sınıfın önüne virtual anahtar anaktar sözcüğü getirilirse bu taban sınıflar
	çoık türetmede birden fazla kez bulunsa bile yalnızca tek kopyası nesne içerisine yerleştirilir
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class X {
public:
	X()
	{
		cout << "X constructor" << endl;
	}
	~X()
	{
		cout << "X destructor" << endl;
	}
};

class A : virtual public X {
public:
	A()
	{
		cout << "A constructor" << endl;
	}
	~A()
	{
		cout << "A destructor" << endl;
	}

};

class B : virtual public X {
public:
	B()
	{
		cout << "B constructor" << endl;
	}
	~B()
	{
		cout << "B destructor" << endl;
	}
};

class C : public A, public B {
public:
	C();
	~C()
	{
		cout << "C destructor" << endl;
	}
};

C::C() : B(), A()
{
	cout << "C constructor" << endl;
}

int main()
{	
	C c;

	return 0;
}

/*--------------------------------------------------------------------------------------------------------
	Çoklu türetmeden çoklu türetilmiş sınıf nesnesinin adresi herhangi bir taban sınıfa dönüştürülebilir. 
	Taban sınıflardakiş sanal fonksiyonlar çoklu türetilmiş sınıfta ayrı ayrı override edilebilirler. 
	Java ve C# gibi dillerde çoklu türetme yoktur. Ancak bu biçimdeki bir çokbiçimli davranıştan faydalanabilmek için
	bu dillere "interface" kavramı sokulmuştur. Aşağıdaki örnek Java ve C#'taki interfaze kavramını karşılamaktadır.
---------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo() = 0;
};

class B {
public:
	virtual void bar() = 0;
};

class C : public A, public B {
public:
	void foo() override
	{
		cout << "C::foo" << endl;
	}

	void bar() override
	{
		cout << "C::bar" << endl;
	}
};


int main()
{	
	A *pA;
	B *pB;
	C c;

	pA = &c;
	pB = &c;

	pA->foo();
	pB->bar();

	return 0;
}

